## 3.1 概述和运输层服务

运输层协议为运行在不同主机上的应用进程之间提供了**逻辑通信**，它是在端系统中实现的；运输层负责将从应用层传递下来的报文转换成运输层分组，我们将这个分组称为**报文段**；运输层之后再将这些报文段传递给网络层，网络层将其封装成网络层分组(即**数据报**)，然后向目的地发送。

### 3.1.1 运输层和网络层的关系

在协议栈中，运输层位于网络层之上，网络层提供了**主机之间**的逻辑通信、运输层提供了**不同主机上的进程之间**的逻辑通信；

运输层能够提供的服务常常受制于底层网络协议的服务模型，但是，即使底层网络协议不能在网络层提供相应的服务，运输层也能提供某些网络层所没有的服务，比如运输层能够提供可靠的数据传输服务。

### 3.1.2 因特网运输层概述

IP服务模型：不确保报文段的交付；不保证报文段的按序交付；不保证报文段中数据的完整性；(不可靠服务)

UDP和TCP的基本职责：将IP提供的在两个端系统之间的交付服务，扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展为进程间交付的功能被称为**运输层的多路复用与多路分解**；进程到进程之间的数据交付和差错检测是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务

TCP为应用程序提供的附加服务：可靠传输、拥塞控制、流量控制；



## 3.2 多路复用与多路分解

- 多路分解：将运输层报文段中的数据交付到正确的套接字的过程；
- 多路复用：在源主机的不同套接字中收集数据块，并为每个数据块封装上首部信息(这将在分解中使用到)从而形成报文段，然后将报文段传递到网络层的过程；

主机如何将一个到达运输层的报文段定向到合适的套接字？(多路分解的过程)

> 在主机上的每个套接字都分配一个了端口号(报文段中有源、目端口号)，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应套接字。然后报文段中的数据通过套接字进入所连接的进程

运输层多路分解的要求：套接字有唯一标识符；每个报文段有特殊字段(源、目端口)来指示该报文段所要交付到的套接字；接下来介绍在主机中它们实际是如何工作的：

### 3.2.1 无连接的多路复用与多路分解

```c
// 主机A创建一个UDP套接字并绑定19175端口，也可以不人为绑定，一般会自动分配
clientSocket = socket(AF_INET, SOCK_DGRAM)
clientSocket.bind(('', 19157))
```

`A: 19157`端口向`B: 12345`端口发送数据块的过程(两者都为UDP端口)：

- 主机A的运输层创建一个运输层报文，其中包括应用程序的数据块、源端口号(19157)、目的端口号(46428)和两个其它值；
- 然后运输层将得到的报文段传递到网络层；网络层将报文段封装到一个IP数据报中，并尽力而为地将报文段传递给接收主机；
- 报文段到达主机B之后，接收主机的运输层就检查报文段中的目的端口号(12345)并将该报文段交付给12345所标识的套接字；

> 一个UDP套接字由一个二元组全面标识，该二元组包含一个目的IP地址和一个目的端口号
>
> 源端口的用途：为接收方提供回复的方法

### 3.2.2 面向连接的多路复用与多路分解

与UDP不同TCP的套接字由一个**四元组(源IP、源端口、目的IP、目的端口)**来标识。因为TCP是面向连接的，只有经过“三次握手”之后才能开始传送数据，TCP服务器应用程序通过“欢迎套接字(监听套接字)"，创建连接套接字，每一个进程对之间有一个独有的用来传送数据的连接套接字；以下是TCP客户-服务器编程的例子：

- TCP服务器应用程序将“欢迎套接字”绑定到12000端口上，等待来自TCP客户的连接；

- TCP客户使用下面代码创建一个套接字并发送一个连接建立请求报文段；

  ```
  clientSocket = socket(AF_INET, SOCK_STREAM)
  clientScoket.connect((servername, 12000))
  ```

- 连接建立请求的目的端口为“欢迎套接字”绑定的端口并且其TCP首部的特定“连接建立位”需要置位；

- 服务器收到对“欢迎套接字”(12000端口)的请求后，就为其创建连接套接字；

  ```
  connectionSocket, addr = serverSocket.accept()
  ```

- 服务器将连接套接字的端口发送给客户，客户进程和服务器之间通过连接套接字进行数据的传送；

### 3.2.3 Web服务器与TCP

连接套接字与进程之间并非总是一一对应的关系；事实上，现在的高性能Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的**新线程**。



## 3.3 无连接运输：UDP

UDP是一个不提供不必要服务的运输层协议；除了复用/分解功能及少量的差错检测外，它几乎没有对IP增加别的东西；虽然UDP不能像TCP那样提供可靠的数据传输，但还是由很多应用选择使用UDP协议，原因主要是以下几点：

- UDP对在应用层发送什么数据以及何时发送数据的控制更为精确(没有拥塞控制、无需重传)；
- 无需建立连接；无需维护连接状态；
- 分组首部开销小；TCP报文段的首部需要20字节，而UDP只需要8字节

> 虽然UDP不提供可靠的数据传输服务，但是基于UDP的应用是可能实现可靠数据传输的，这可通过在应用程序自身中建立可靠性机制来完成，例如，Chrome浏览器所使用的QUIC协议就是在UDP之上的应用层实现了可靠性

### 3.3.1 UDP报文结构

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231022144232805.png" alt="image-20231022144232805" style="zoom: 67%;" />

### 3.3.2 UDP检验和

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231103112408325.png" alt="image-20231103112408325" style="zoom:50%;" />

在计算检验和时，要在UDP用户数据报之前增加12B的**伪首部**，伪首部既不向下传送也不向上递交，仅仅是为了计算校验和；以下是计算检验和的一个例子(假设只有3个16bit的字)：

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231103112823303.png" alt="image-20231103112823303" style="zoom: 67%;" />

- 发送方：对UDP报文段中所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷(最高位如果有溢出，低位则需要+1)。得到的结果被放在UDP报文段中的检验和字段；
- 接收方：全部的4个16比特字(包括检验和)加在一起。如果和的结果全为1，则没有出现差错，如果这些比特之一是0，则分组出现了差错；



## 3.4 可靠数据传输原理

### 3.4.1 经完全可靠信道的可靠数据传输：rdt1.0

```c
// rdt1.0: 发送端动作					 // rdt1.0: 接收端动作
loop (true) {							loop (true) {
	switch (事件)								switch (事件)
		事件：等待来自上层的调用;					事件：等待来自下层的调用；		
			rdt_send(data);							rdt_rcv(packet);	
		break;									 break;
}										}

rdt_send(data) {						rdt_rcv(packet) {
	packet = make_pkt(data);				extract(packet, data);
	udt_send(packet);						deliver_data(data);
}										}
```



### 3.4.2 经具有比特差错信道的可靠数据传输：rdt2.0

> 发送的分组按序接收但存在比特差错

现实中，当你通过电话向对方说了一串手机号，对方听清楚了之后一般会回复“ok”或“嗯”，如果没有听清楚对方往往会让你重复一遍，这里的“ok”就相当于**肯定确认**、重复一遍就相当于**否定确认**；**自动重传请求协议**(Automatic Repeat reQuest，ARQ协议)就是基于这样的机制实现的，ARQ协议还需另外三种协议功能来处理存在比特差错的情况：**差错检测**、**接收方反馈**、**重传**

```c
// rdt2.0: 发送端动作
loop (true) {
	switch (事件)	
		事件：等待来自上层的调用
			rdt_send(data) {
				sndpkt = make_pkt(data, checksum);
				udt_send(sndpkt);
			}
			break;	
		事件：等待ACK或NAK	
			while (rdt_rcv(rcvpkt) && isNAK(rcvpkt)) }
				udt_send(sndpkt)
			break;(接收到了ACK)
}

// rdt2.0: 接收端动作
loop (true) {
	switch (事件)
		事件：等待来自下层的调用
			if (rdt_rcv(rcvpkt) && corrupt(rcvpkt)) {
				sndpkt = makt_pkt(NAK);
				udt_send(sndpkt);
			} else if (rdt_rcv(rcvpkt) && notcorrupt(rcvpkt)) {
				extract(rcvpkt, data);
				deliver_data(data);
				sndpkt = make_pkt(ACK);
				udt_send(sndpkt);
			}
			break;
}
```

当发送方处于等待ACK(positive acknowledge)或NAK(negative acknowledge)状态时，它不能从上层获得数据；也就是说，rdt_send()事件不可能出现；发送方不会发送一块新数据，除非发送方确定接收方已经正确的接收到当前分组，因此，rdt2.0协议被称作**停等协议**

在rdt2.0中我们没有考虑到**ACK或NAK分组受损**的可能性，如果受损，协议应该怎样纠正ACK或NAK分组中的差错？可以考虑以下三种解决方式

- “312xxx231”、“请重xxx遍”、“你说什么”、“请重复一遍”、“312312231”，如果接收方无法正确接收“你说什么”，显然这种方法无法结局纠正ACK或NAK分组中的差错
- 增加足够的检验和比特，使发送方不经可以检测差错，还可以恢复差错
- 当发送方收到含糊不清的ACK或NAK分组时，只需重传当前数据分组即可。然而，这种方法会在发送方和接收方的信道中引入**冗余分组**，接收方无法知道上次发送的ACK或NAK是否被正确地收到，因此无法知道接收到的分组是新的还是一次重传。

一般通过在数据分组中添加一个新字段，让发送方对其数据分组编号，将数据分组的序号放在该字段中；接收方只需检查序号即可确定该分组是否为一次重传，对于这种简单的情况，只需要1比特序号就足够了，因为它可让接收方知道发送方是否正在重传前一个分组(接收到的分组序号与最近接收到的分组序号相同)

```c
// rdt2.1: 发送端动作
loop (true) {
	switch (事件)
		事件：等待来自上层的调用0
			rdt_send(data) {
				sndpkt = make_pkt(0, data, checksum);
				udt_send(sndpkt);
			}
			break;
		事件：等待ACK或NAK 0(只有接收到了ACK且分组没有损坏才转换到下一等待状态)
			while (rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isNAK(rcvpkt)))
				udt_send(sndpkt);
			break;
		事件：等待来自上层的调用1
			rdt_send(data) {
				sndpkt = make_pkt(1, data, checksum);
				udt_send(sndpkt);
			}
			break;
		事件：等待ACK或NAK 1(只有接收到了ACK且分组没有损坏才转换到下一等待状态)
			while (rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isNAK(rcvpkt)))
				udt_send(sndpkt);
			break;(接收到了ACK且分组没有损坏)
}
```

```c
// rdt 2.1: 接收端动作
loop (true) {
	switch (事件)
		事件：等待来自下层的0
			if (rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq0(rcvpkt)) {
				extract(rcvpkt, data);
				deliver_data(data);
				sndpkt = make_pkt(ACK, checksum);
				udt_send(sndpkt);
				break;
			} else if (rdt_rcv(rcvpkt) && corrupt(rcvpkt)) {
				sndpkt = make_pkt(NAK, checksum);
				udt_send(sndpkt);
			} else if (rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq1(rcvpkt)) {
				sndpkt = make_pkt(ACK, checksum);
				udt_send(sndpkt);
			}
			（0号分组到了且未损坏才执行下一事件，否则一直等0）
		事件：等待来自下层的1
			if (rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq1(rcvpkt)) {
				extract(rcvpkt, data);
				deliver_data(data);
				sndpkt = make_pkt(ACK, checksum);
				udt_send(sndpkt);
				break;
			} else if (rdt_rcv(rcvpkt) && corrupt(rcvpkt)) {
				sndpkt = make_pkt(NAK, checksum);
				udt_send(sndpkt);
			} else if (rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq0(rcvpkt)) {
				sndpkt = make_pkt(ACK, checksum);
				udt_send(sndpkt);
			}
			（1号分组到了且未损坏才执行下一事件，否则一直等1）
}
```

发送方接收到对同一个分组的两个ACK(即接收**冗余ACK**)后，就知道接受方没有正确的接收到跟在被确认两次的分组后面的分组，因此只使用ACK也可以达到ACK和NAK同时使用的效果，rdt2.2是在有比特差错的控制信道上实现的一个**无NAK**的可靠数据传输协议

```c
// rdt2.2: 发送端动作
loop (true) {
	switch (事件)
		事件：等待来自上层的调用0
			rdt_send(data) {
				sndpkt = make_pkt(0, data, checksum);
				udt_send(sndpkt);
			}
			break;
		事件：等待ACK0
			while (rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isACK(rcvpkt, 1)))
				udt_send(sndpkt)	// 在等待ACK0时收到了ACK1，说明了ACK1发了两次，即接收方没有收到刚刚发出的分组
			break;(收到刚发出的分组的第一个ACK且分组没有损坏时退出)
		事件：等待来自上层的调用1
			sndpkt = make_pkt(1, data, checksum);
			udt_send(sndpkt);
		事件：等待ACK1
			while (rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isACK(rcvpkt, 0)))
				udt_send(sndpkt)	// 在等待ACK1时收到了ACK0，说明了ACK0发了两次，即接收方没有收到刚刚发出的分组
			break;(收到刚发出的分组的第一个ACK且分组没有损坏时退出)
}
```

```c
// rdt2.2: 接收端动作
loop (true) {
	switch (事件)
		事件：等待来自下层的0
            if (rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq0(rcvpkt)) {
                    extract(rcvpkt, data);
                    deliver_data(data);
                    sndpkt = make_pkt(ACK, 0, checksum);
                    udt_send(sndpkt);
                    break;
                } else if (rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || has_seq1(rcvpkt))) {
                    sndpkt = make_pkt(ACK, 1, checksum);
                    udt_send(sndpkt);
                }
                （0号分组到了且未损坏才执行下一事件，否则一直等0）
        事件：等待来自下层的1
        	if (rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq1(rcvpkt)) {
                    extract(rcvpkt, data);
                    deliver_data(data);
                    sndpkt = make_pkt(ACK, 1, checksum);
                    udt_send(sndpkt);
                    break;
                } else if (rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || has_seq0(rcvpkt))) {
                    sndpkt = make_pkt(ACK, 0, checksum);
                    udt_send(sndpkt);
                }
                （1号分组到了且未损坏才执行下一事件，否则一直等1）
}
```

### 3.4.3 经具有比特差错的丢包信道的可靠数据传输：rdt3.0

现假定除了比特受损外，底层信道还会丢包，所以该如何检测丢包？以及丢包后该做什么？有很多可以解决这两个问题的方法，一般使用的方法是由发送方负责检测和恢复丢包，当发送方等待一段时间后，若未收到对某一分组的确认即重传该分组，该等待时间称为**超时重传时间**(至少为一个rrt加上接收方处理一个分组的时间)。为了实现超时重传，发送方需要做到：**每次发送一个分组(包括第一次分组和重传分组)时，便启动一个定时器**；**响应定时器中断(采取适当的动作)**；**终止定时器**；

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231022171428636.png" alt="image-20231022171428636" style="zoom:67%;" />

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231022171445757.png" alt="image-20231022171445757" style="zoom:67%;" />

### 3.4.4 流水线可靠数据传输协议

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231103115352276.png" alt="image-20231103115352276" style="zoom:67%;" />

> 假定1200km的信道的RTT = 20ms，分组长度为1200bit，A的发送速率为1Mbit/s，忽略T_A(T_A<<T_D)，此时信道利用率U = 5.66%，若A的发送速率为10Mbit/s，则U=0.00596，此时信道利用率已经很低了；

rdt3.0虽然是一个正确的协议，但因为它是停等协议，所以它的**发送方(信道)利用率**很低(发送方利用率为发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比)，为了提高停等协议的发送方利用率，因此提出了使用流水线方式进行发送——不以停等方式运行，允许发送方发送多个分组而无需等待确认，但引入流水线技术也对可靠数据传输协议带来了一些影响：

- 因为每个传送的分组(不算重传的)必须有一个唯一的序号，所以**必须增加序号的范围**；
- **发送方必须缓存那些它已经发送但还未确认的分组**(用于重传)、**接收方必须缓存已正确接收的分组**(如果分组不是按序到达，接收方必须缓存之后，再按序发送给上一层)
- 解决流水线差错恢复的两种基本方法：**回退N步**(Go-Back-N，GBN)和**选择重传**(Selective Repeat, SR)

### 3.4.5 回退N帧(滑动窗口协议)

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231022204943746.png" alt="image-20231022204943746" style="zoom:67%;" />

在GBN中，允许发送方发送多个分组而无需等待确认，但已发送还未确认的分组不能超过N；那些已被发送但还未确认的分组的许可序号范围可以被看成是一个长度为N的窗口，随着协议的运行，该窗口在序号空间向前滑动。因此N常被称作**窗口长度**，GBN协议也常被称作**滑动窗口协议**；

> 为什么要限制窗口长度为N？原因之一流量控制

```c
// 基于ACK、无NAK的GBN协议的发送方的FSM
base = 1;	// 最先发送但还未确认的分组的序号
nextseqnum = 1;	// 可立即发出的分组的序号

loop (true) {
	switch (事件)
		事件：从上层应用程序接收到数据
			rdt_send(data) {
				if (nextseqnum < base + N) {	// 窗口未满，可发送数据
					sndpkt[nextseqnum] = make_pkt(nextseqnum, data, checksum);
					udt_send(sndpkt[nextseqnum]);
					if (base == nextseqnum) start_timer;
					nextseqnum ++;
				} else refuse_data(data);
			}
			break;
		事件：定时器超时
			start_timer;
			udt_send(sndpkt[base]);
			udt_send(sndpkt[base + 1]);
			...
			udt_send(sndpkt[nextseqnum - 1]);
			break;
		事件：收到ACK且没有比特差错
			base = getacknum(rcvpkt) + 1;
			if (base == nextseqnum) stop_timer;
			else start_timer;
			break;
		事件：收到ACK有比特差错
			break;
}
```

- 定时器超时：出现超时时，发送方重传所有已发送但还未被确认过的分组，这也是“回退N帧”的来源；
- 第一次发送分组或者在发送完所有分组并收到确认后会出现`base = nextseqnum`的情况，即这两种情况下会启动计时器；接收到未损坏的ACK且还有未确认的分组时，会重启计时器；接收到未损坏的ACK且没有分组可发时，会停止计时器；

```c
// 基于ACK、无NAK的GBN协议的接收方的FSM
expectedseqnum = 1	// 期望收到的分组的序号，为了保证收到的分组有序而定义的
sndpkt = make_pkt(0, ACK, checksum);

loop (true) {
	switch (事件)
		事件：接收到来自下层的所期望序号的没有比特差错的分组
			extract(rcvpkt, data);
			deliver_data(data);
			sndpkt = make_pkt(expectedseqnum, ACK, checksum);
			udt_send(sndpkt);
			expectedseqnum ++;
			break;
		事件：默认操作
			udt_send(sndpkt);
			break;
}
```

- 接收方只接收按序到来的且没有比特差错的分组；在其他所有情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送ACK；
- GBN的接收方采用**累积确认**，即接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示，到这个分组为止的所有分组都已正确接收到了；

### 3.4.6 选择重传

当窗口长度很大时，GBN会有大部分事件用于重传，从而降低了数据的传输速度，因此提出了选择重传协议。顾名思义，选择重传(SR)协议就是通过让发送方仅重传那些它怀疑在接收方出错(即丢失或受损)的分组，从而避免不必要的重传；

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231022214846837.png" alt="image-20231022214846837" style="zoom:67%;" />

```c
// SR发送方的事件与动作
- 从上层收到数据：
	- 当从上层收到数据后，SR发送方检查下一个可用于该分组的序号
	- 如果序号位于发送方的窗口内，则将数据打包发送
	- 否则就像GBN中一样，要么将数据缓存，要么将其返回给上层以便以后传输
- 超时：
	- 因为超时发生后只能发送一个分组，所以每个分组需要有一个自己的定时器
	- 如果超时，则重传超时的分组
- 收到ACK：
	- 如果收到ACK，倘若该分组序号在窗口内，则SR发送方将那个被确认的分组标记为已接收
	- 如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处
```

```c
// SR接收方的事件与动作
- 序号在[rcv_base, rcv_base + N - 1]内的分组被正确接收：
	- 返回一个对应的ACK
	- 如果该分组以前没收到过，则缓存该分组
	- 如果该分组的序号等于rcv_base，则该分组以及以前缓存的序号连续的分组交付给上层
	- 然后，接收窗口向前移动
- 序号在[rcv_base - N, rcv_base - 1]内的分组被正确接收：
	- 在此情况下必须产生一个ACK，即使该分组是接收方以前已确认过的分组
- 其他情况：
	- 忽略分组
```

> SR接收方第二个事件解释：当接收方发送的ACK丢失时，接收窗口认为该分组已被正确接收，而发送窗口认为该分组未被正确接收(因此导致了窗口的不一致)，会重传该分组，如果不对[rcv_base - N, rcv_base - 1]内的分组返回ACK的话，在丢失ACK时，发送方会永远认为该分组未被正确接收，导致发送方窗口无法移动，进而导致无法传输数据；
>
> SR中发送方和接收方的窗口并不总是一致；

![image-20231023131156348](C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231023131156348.png)

- 对于SR协议，当窗口长度比序号空间小于1时，无法正常工作，如上图所示（窗口长度必须小于等于序号空间大小的一半）



