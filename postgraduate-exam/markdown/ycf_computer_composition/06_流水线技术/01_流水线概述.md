## 6.1 流水线概述

流水线的**设计原则**：指令流水段的个数以最复杂指令所用的功能段个数为准；流水段的长度以最复杂的操作所花时间为准；

流水线计算例子，lw指令的流水段划分和各段所用时间为，取指：200ps；寄存器读：50ps；ALU操作：100ps；存储器读：200ps；寄存器写：50ps，不考虑控制单元、PC访问、信号传递等延迟

- 执行一条lw指令：串行：600ps；流水线：1ns；因此流水线方式并**不能缩短一条指令的执行时间**
- 执行N条lw指令：串行：600Nps；流水线：(5+N-1)200ps；当N很大时，流水线方式的吞吐率是串行执行方式的3倍
- 若流水段的个数为M，每个流水段的执行时间为T，则N条指令的执行总时间=MT+(N-1)T=**(M+N-1)T**
- 当N很大时且每个功能段划分均匀，使得串行执行一条指令和流水线方式执行一条指令的时间大致相同时，流水线方式的**吞吐率可以达到串行执行方式的M倍**，即流水段的个数

**具有什么特征的指令集有利于实现指令流水线**？

- 指令长度应尽量一致。有利于简化取指令和指令译码操作
- 指令格式应尽量规整，尽量保证源寄存器的位置相同。有利于在指令未知时就可取寄存器操作数
- 采用装入/存储型指令风格，可以保证除Load/Store指令外的其它指令都不访问存储器，这样可以把Load/Store指令的地址计算和运算指令的执行步骤规整在同一个周期中，因此，有利于减少操作步骤，规整流水线
- 数据和指令在存储器中要“对齐”存放。有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到



## 6.2 流水线处理器的实现

### 6.2.1 每条指令的流水段分析

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231010213055783.png" alt="image-20231010213055783" style="zoom:80%;" />

- 每条指令的前两个功能段都一样，Ifetch: 取指令并计算PC+4；Reg/Dec: 寄存器取数并译码。后面的功能段随各指令的功能的不同而不同
- R型指令：都涉及在ALU中对Rs和Rt内容进行运算，最终把结果送Rd的操作（对于需要判断溢出的程序，如果溢出了，则不会送Rd，会直接转异常处理程序），所以需要Exec功能段，用于在ALU中进行计算；Write功能段，用于将结果写回寄存器
- I型指令：都涉及对16位立即数进行符号扩展或零扩展，然后和Rs的内容进行运算，最终将结果送Rt的操作。显然，I型指令的功能段划分与R型指令的划分相同
- lw指令：$M[R[Rs] + SignExt(imm16)]\rightarrow R[Rt]$，lw需要从存储器中读取数据，所以多了一个Mem段，用于从存储器中读数据
- sw指令：$R[Rt]\rightarrow M[R[Rs] + SignExt(imm16)]$，sw是将寄存器中的数据写入存储器中，和lw相比，没有Write段，只有Mem段，用于将数据写入寄存器
- beq指令：$if(R[Rs]=R[Rt])\,\,\,\,PC\leftarrow PC+4+(SignExt(imm16)*4) \,\,\,\,else\,\,\,\, PC\leftarrow PC+4$，Exec功能段，用于在ALU中做减法以比较是否相等，同时用加法器计算转移地址；WrPC功能段，用于在比较相等的情况下，将转移目标地址写到PC中，由于写PC的时间要比写存储器的时间短，可以将WrPC向Mem靠，即最后的功能段用Mem表示。因此，beq的功能段划分类似与sw指令
- J型指令：J型指令是无条件转移指令，功能为直接将目标地址送PC，所以其功能划分很简单，除了两个公共的功能段外，就只有一个WrPC，其操作时间比Exec短
- 每个指令所需的流水段的个数不同，为了使指令规则，一般通过加入“空”功能段来向最复杂的指令靠齐。插入“空”段需遵循的原则：
  - 每个功能部件每条指令只能使用一次
  - 每个功能部件必须在相同的阶段被使用

### 6.2.2 流水线数据通路的设计

![image-20231011151849548](C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231011151849548.png)

- 流水段之间存在流水段寄存器，用来存放从当前流水段传到后面所有流水段的信息。由于每个段间传递的信息不同，所以**各流水段寄存器的长度**也**不一样**

- **IF段**：实现**取指令并计算下一条指令**的功能。

  - **顺序执行时**，根据当前PC中的内容到IM中取指令，将取出的指令送IF/ID，同时PC+4，之后将PC+4送MUX、IF/ID，由于此时不是转移指令，PC+4送到MUX之后就被立即送到PC中了
  - 转移执行时（**beq**），根据当前PC中的内容到IM中取指令，将取出的指令送IF/ID，根据Exec阶段执行得到的Zero、ID阶段得到的Branch，控制MUX是否将PC+4+SignExt(imm16)送PC
  - **无条件转移时**，取指令部分相同，下一条指令的形成过程：在Exec阶段，将Rs、Rt、Rd、imm16拼接起来形成target，然后PC<31 : 28>||target形成转移目标地址，送Ex/Mem，然后在Mem阶段送PC，在IF的MUX后再加一个MUX，使用控制信号jump控制是否将jump指令生成的转移目标地址送PC，jump信号在ID段生成

- **ID段**：根据指令中Rs和Rt的值到寄存器堆中**取出相应寄存器的值**，同时**对指令中的操作码op字段进行译码，生成相应的控制信号**。MC(Main Control)**一般用硬布线控制器来实现**，因为流水线一般采用RISC，使用硬布线控制器可以提高指令的执行效率

  - 某一时刻每个流水段执行的是不同指令的某个阶段，所需的控制信号不同，因而某一时刻每个流水段中的控制信号应该是正在执行指令的对应功能段的控制信号

  - 个人理解：

    - 假设lw需要的控制信号为a、b、c（a在Exec段使用，b在Mem段使用，c在Write段使用）
    - ori所需的控制信号为a、b、e、f（a在Exec段使用，b、e在Write段使用，f在Write段使用）
    - add所需的控制信号为a、g（a在Exec段使用、g在Write段使用）
    - 在第二个时钟周期内，lw译码，lw的控制信号a、b、c被送到ID/Ex中；在第三个时钟周期，ori译码，ori的控制信号a、b、e、f被送到ID/Ex中，同时lw的控制信号a在Exec中被使用了，剩余b、c，lw的b、c被送到Ex/Mem中；第四个时钟周期，add译码，add的a、g被送到ID/Ex中，同时ori的a在Exec阶段被使用，剩余b、e、f，ori的b、e、f送Ex/Mem，lw的b在Mem阶段被使用，剩余c，在之后的几个时钟周期内指令执行完
    - 总结：虽然每条指令有时会需要相同的控制信号，但是每条指令的控制信号的生成总是差一个时钟周期，当lw中a在Exec阶段使用完之后，ori的a才生成

    <img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231011161941743.png" alt="image-20231011161941743" style="zoom: 50%;" />

- **Exec段**：**Ex段的功能由具体指令确定**，不同指令经ID段译码后得到不同的控制信号，用来控制执行部件进行不同的操作

  - **R型指令**：在ALU中对busA和busB传递来的数据执行相应的运算，运算结果送ALUout，并产生Zero和Overflow信号
  - **I型运算类指令**：在ALU中对立即数扩展后的数据与busA传递来的数据执行相应的运算，运算结果送ALUout，并产生Zero和Overflow信号
  - **ls/sw指令**：在ALU中对立即数符号扩展后的数据与busA传递来的数据执行加法运算，得到存储器地址送ALUout
  - **beq指令**：在ALU中对busA和busB传递来的数据执行减法运算，得到Zero标志；同时对立即数进行符号扩展，在加法器中与“PC+4”相加，得到转移目标地址
  - **j指令**：生成转移目标地址，即PC<31 : 28>||target<25 : 0>

- **Mem段**：**Mem流水段的功能也由具体指令确定**

  - **R型指令、I型运算类指令**：空操作，只需将相应的信息送到下一个流水段即可
  - **ls指令**：取数操作。在Ex段得到的地址被送到DM的读地址端RA经过一段存取时间，数据从DM的输出端Do送到Mem/Wr
  - **sw指令**：存数操作。在Ex段得到的地址被送到DM的写地址端WA，同时把Ex/Mem中要存的是数据R[Rt]送DM的输入端Di，经过一段存储时间后，数据被存入DM中
  - **beq指令、j指令**：将Ex段生成的转移目标地址更新到PC中

- **Wr段**：根据控制信号将Exec段产生的信息写入Rfile寄存器堆中，Rfile的WE由Overflow和控制信号RegWr共同决定，Rfile的写数据端口Di的信息来源于Wr段的MUX

  - **R型指令、I型运算类指令**：RegWr=1，MemtoReg=0，选择将ALU的输出结果送Di，目的寄存器送Rfile的Rw
  - **lw指令**：RegWr=1，MemtoReg=1，选择将DM的读出结果送Di，目的寄存器送Rfile的Rw
  - **sw、beq或j型指令**：RegWr=0，MemtoReg=x，任何寄存器的值都不改变



## 6.3 流水线冒险及其处理

 ### 6.3.1 结构冒险

结构冒险也称作硬件资源冲突，它是由硬件资源竞争造成的。可以从两个方面出发解决结构冒险：

- 使用**功能段划分**，一个部件每条指令只能使用一次且只能在特定的流水段使用，这可以避免一部分的结构冒险
- 通过**设置多个独立的部件**来避免硬件冲突。例如**寄存器访问冲突**、**存储器访存冲突**

### 6.3.2 数据冒险

数据冒险也称作数据相关，引起数据冒险的原因在于后面指令用到前面指令结果时前面指令还没有产生。在非“乱序”执行的基本流水线中，所有的数据冒险都属于RAW(Read After Write，写后读)数据冒险，对于**RAW数据冒险**可以采取以下措施：

- 插入**空操作**：在编译时预先插入空操作指令nop。好处是硬件简单，坏处是既浪费了存储空间又浪费了执行执行时间
- 插入**气泡**：通过硬件阻塞(stall)方式阻止后序指令的执行。好处是只浪费了时间，坏处是硬件复杂
- 采用**转发**技术：将数据通路中生成的中间数据直接转发到ALU的输入端

**WAR**(Write After Read，读后写)**数据冒险**：一条指令读一个寄存器或内存位置，而后续的指令将改写该寄存器或内存位置的内容。如果在读操作完成之前，写操作就开始进行，那么就会发生冒险

**WAW**(Write After WAW，写后写)**数据冒险**：两条指令要改写同一个寄存器或内存位置。如果这两条指令的写操作发生次序与期望的次序相反，那么就会发生冒险

### 6.3.3 控制冒险

正常情况下，指令在流水线中总是按顺序执行，当遇到改变指令顺序的情况时，流水线中指令的正常执行会被阻塞，这种由于发生了指令执行顺序改变而引起的流水线阻塞称为控制冒险。各类**转移指令（包括调用、返回指令等）的执行**，以及**异常和中断的出现**都会改变指令的执行顺序，因而**都可能引发控制冒险**

- **由转移指令引起的控制冒险**（分支冒险）

  <img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231012104437356.png" alt="image-20231012104437356" style="zoom:67%;" />

  - 假设bep在Ex阶段得到的转移目的地址为1000，Zero和Branch有效，则正确的指令执行流程是执行完12:beq之后立即执行1000:lw，但实际上12和1000之间还隔了三条指令，这三条指令是不应该执行的，因此发生了冒险。通常把由于流水线阻塞而带来的延迟称为**延迟损失时间片C**，此时C=3
  - 采用**插入空操作指令或气泡**可以解决此类冒险，但是当beq指令不需要转移时，就不会发生冒险，如果对于所有的beq指令都采用插入空操作指令或气泡显然会产生不必要的浪费，因此，一般采用简单预测或动态预测的方式来解决分支冒险问题
  - **简单预测**：总是预测条件满足或条件不满足
  - **动态预测**：利用分支指令发生转移的历史情况来进行预测，并根据实际情况动态调整预测位
  - **延迟分支**的方法也可以解决分支冒险。主要思想是：采用编译优化来调整指令顺序，把分支指令前与分支指令无关的指令调到分支指令后面执行，以填充延迟损失时间片，不够时用nop操作填充

- **由异常或中断引起的控制冒险**

  - 通过在数据通路的不同流水段中加入相应的检测逻辑可检测出哪条指令发生了异常；在一个时钟周期内，如果检测到了多个异常，则先响应最先被执行的指令的异常，外部中断请求最后响应，即Wr>Mem>Ex>ID>IF>外部中断
  - 处理器硬件对异常和中断引起的冒险大致的处理过程：
    - 首先，清除发生异常的指令以及其后在流水线中的所有指令
    - 然后保存断点，并将异常处理程序的首地址送PC
  - 若正在执行的指令序列为lw-add-ori…，lw会在Mem段发生“缺页”、add会在Ex段发生“溢出”，ori会在IF段发生“指令地址越界”，按照上面的做法会先执行ori的中断，正确的做法应该是先执行lw的中断再执行add的中断再执行ori的，如果先执行ori的中断，lw、add的中断就会被忽略，因此通常的做法是：
    - 将多个流水段发生的异常的原因断点先记录到特定的寄存器中，并将发生异常的标记同时记录到流水段寄存器中，发生异常的指令在流水线中继续执行
    - 直到执行到最后一个阶段，由最后阶段的硬件检测本指令是否发生过异常或此时是否由外部中断发生，若有，则清除流水线中正在执行的指令，然后转到相应的异常处理程序执行

  

  ## 6.4 高级流水线技术

  ![image-20231012140223145](C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231012140223145.png)

  