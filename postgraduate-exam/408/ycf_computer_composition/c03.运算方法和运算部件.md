
### 3.1 高级语言和机器指令中的运算

#### 3.1.1 $\text{C}$ 程序中涉及的运算

1. 基本算数运算：无符号数、带符号数和浮点数的加、减、乘、除；
2. 按位运算：与 $\&$、或 $|$、非 $\sim$、异或 $\wedge$；
    
    按位运算的一个重要应用就是实现掩码操作，比如 $\text{0x0F \& 0x8C = 0x0C}$，通过掩码 $\text{0x0F}$ 提取了一个字节的低四位。 
3. 逻辑运算：与 $\&\&$、或 $||$、非 $!$；

    注意逻辑运算和按位运算的区别：逻辑运算是非数值计算，其操作数只有两个逻辑值——$\text{ True}$ 和$\text{ False}$，结果也只有这两种可能，一般非零为$\text{ True}$、全零为$\text{ False}$；按位运算是一种数值运算，运算时将两个操作数中对应的二进制位按指定的逻辑运算规则逐位进行计算。
4. 移位运算：分为逻辑位移和算数位移；

    逻辑左移和算数左移相同，都是高位移出，低位补 $0$；逻辑右移，低位移出，高位补 $0$；算数右移，低位移出，高位补符号位。

    左移 $k$ 位相当于数值乘以 $2^k$，所以左移可能会发生溢出；右移 $k$ 位相当于数值除以 $2^k$。

    移位运算中的溢出判断：对于无符号整数的逻辑左移，如果高位移出的是 $1$，则发生溢出；对于带符号整数的算数左移，如果左移前、后符号位不同，则发生溢出。

5. 位扩展和位截断运算：$\text{C}$ 语言中没有明确的位扩展/截断运算符，在进行数据类型转换时，短数向长数转换会进行位扩展；长数向短数转换会进行位截断；
   
   位扩展有两种方式 $0$ 扩展和符号扩展，顾名思义，一种方法是在扩展时往前补 $0$，另一种补符号。$0$ 扩展用于无符号数；符号扩展用于补码表示的带符号整数。

### 3.2 基本运算部件

在计算机中，运算器由算术逻辑单元 $\text{(Arithmetic Logic Unit, ALU)}$、移位器、程序状态字寄存器 $\text{(Program Status Word, PSW)}$ 和通用寄存器组等组成。运算器的基本功能包括算术运算（加、减、乘、除）和逻辑运算（与、或、非、异或），以及移位、求补等操作。$\text{ALU}$ 的核心部件是加法器。

#### 3.2.1 串行进位加法器

全加器用来实现两个本位数加上低位进位生成一位本位结果和一位向高位的进位。第 $i$ 位的加法运算是指第 $i$ 位的加数 $X_i,\,\,Y_i$ 和低位来的进位 $C_{i-1}$ 三者相加，生成第 $i$ 位结果 $F_i$ 和第 $i$ 位进位 $C_i$。

<img src='./img/图3-1 全加器.png' />

将 $n$ 个全加器相连可得 $n$ 位全加器，如图实现了$X=X_nX_{n-1}...X_1$ 和 $Y=Y_nY_{n-1}...Y_1$ 逐位相加的功能。这种结构所用元件较少，但进位传递时间较长。

$ALU$ 的核心是加法器，提高加法器的速度至关重要，串行进位加法器速度慢的主要原因是进位按串行方式传递，高位进位依赖低位进位，为了提高加法器的速度，因此要尽量避免进位之间的依赖关系。并行进位的加法器可以解决这个问题。

#### 3.2.3 带标志加法器

$n$ 位无符号数加法器只能用于两个 $n$ 位二进制数相加，不能进行无符号整数的减运算，也不能进行带符号整数的加/减运算。要能够进行无符号整数的加/减运算和带符号整数的加/减运算，还需要在无符号数加法器的基础上增加相应的逻辑门电路，使得加法器不仅能计算和/差，还要能够生成相应的标志信息。

<img src='./img/图3-2 带标志加法器.png' />

需要说明的是，为了加快加法运算的速度，真正的电路一定使用多级先行进位方式。右图主要是为了说明如何从加法运算结果中获得标志信息，因而使用全加器简化了加法器电路。

加法器除了产生计算结果外，还会产生一些标志信息，
1. $OF=C_n \oplus C_{n-1}$
   
   $\text{Overflow Flag}$ 溢出位，当计算结果溢出时，该位为 $1$。
2. $SF=F_{n-1}$
   
   $\text{Sign Flag}$ 符号位，结果为正，该位为 $1$，反之为 $0$。
3. $ZF=(F==0)$

   $\text{Zero Flag}$ 零标志位，结果位 $0$，该位为 $1$。
4. $CF=C_{out} \oplus C_{in}$
   
   $\text{Carry Flag}$ 进位/借位标志位，加法最高位进位或减法最高位借位时为 $1$，其余为 $0$。

以上标志位由 $\text{ALU}$（$\text{ALU}$ 中的加法器）产生，然后存储于 $\text{PSW (Program Status Word)}$ 中，每个标志位占 $1$ 位。$\text{PSW}$ 中还有其它的标志位，只是我们考试只考这四位。

#### 3.2.4 算数逻辑部件

$ALU$ 是一种能进行多种算术运算与逻辑运算的组合逻辑电路，其核心部件是带标志加法器，多采用先行进位方式。通常用下图左所示的符号来表示。其中 $A$ 和 $B$ 是两个 $n$ 位操作数输人端，$Cin$ 是进位输入端，$ALUop$ 是操作控制端，用来决定 $ALU$ 所执行的处理功能。例如，$ALUop$ 选择 $Add$ 运算，$ALU$ 就执行加法运算，输出的结果就是 $A$ 加 $B$ 之和 $ALUop$ 的位数决定了操作的种类，例如，当位数为 $3$ 时，$ALU$ 最多只有 $8$ 种操作。

下图右给出了能够完成 $3$ 种运算 “与” “或” 和 “加法” 的一位 $ALU$ 结构图。其中，一位加法用一个全加器实现，在 $ALUop$ 的控制下，由一个多路选择器 $(MUX)$ 选择输出 $3$ 种操作结果之一。这里有 $3$ 种操作，所以 $ALUop$ 至少要有两位。

<img src='./img/图3-3 算术逻辑单元.png' />

### 3.3 定点数的运算

定点数的运算主要包括：
- 无符号数的按位逻辑运算；
- 无符号的逻辑移位运算、带符号的算术移位运算；
- 无符号数/带符号数的位扩展和截断运算；
- 无符号数/带符号数的加减乘除运算；

我们主要学习无符号数/带符号数的加减乘除运算。

#### 3.3.1 补码加减运算

由补码的定义可得，在加减法运算中，补码的符号位可以一起运算；并且补码表示法可以实现加减法的统一，即减法可以转换成加法进行计算。所以，对于 $n$ 位补码的加减可以使用 $n$ 位加法器进行运算。下图是 $n$ 位补码加减运算部件的实现，
>对于减法 $[x-y]_补 = [x]_补+[-y]_补$，求得 $-y$ 的补码即可将减法转换为加法。求一个负数的补码可以由其补码 “各位取反，末位加 $1$” 得到。

<img src='./img/图3-4 补码加减运算部件.png'>

在 $n$ 位加法器的基础上，补码加减运算部件多了一个多路选择器和一个控制信号 $\text{Sub}$。当控制信号 $\text{Sub = 1}$ 时，做减法，它控制 $\text{MUX}$ 输出 $\overline{Y}$，然后 $\text{Sub=1}$ 作为加法器的 $Cin$ 实现加一，对 $Y$ 进行了取反加一，将减法变为加法；当控制信号 $\text{Sub = 0}$ 时，做加法。

加法器就是对两个 $n$ 位输入，从最低位开始，按位相加，并往更高位进位。无符号数和带符号数的加法都是按这个原理相加的，所以两者的加法可以用相同的运算部件实现，只是解释方法不同。

那么减法呢？计算机本身可以看作一个模运算系统，因为它的位数是有限的，总会出现溢出的现象，溢出就相当于对结果取模，例如一个四位的系统，$1111 + 0001 = 0000$，结果模 $2^4$ 所以结果为 $0$。又因为补码就是由模运算系统得到的，所以无符号数的减法运算也可以像补码一样转换为加法。

因此，上图中的电路同时也能实现无符号整数的加/减运算。可以通过标志信息来区分带符号整数和无符号整数的运算结果。

- 零标志 $ZF = 1$ 表示 $F = 0$。对无符号数、带符号数都有意义；
- 符号标志 $SF$ 为 $F$ 的最高位。只对带符号数有意义；
- 进/借位标志 $CF$ 表示无符号数加/减运算时的进位/借位。只对无符号数有意义； 
  - 加法时，$CF=1$ 表示无符号数加法溢出；减法时，$CF=1$ 表示有借位，即不够减；
  - 因此，加法时，$CF$ 就应等于进位输出 $Cout$；减法时，就应将进位输出 $Cout$ 取反来作为借位标志。所以 $CF = Sub\oplus Cout$。
      >减法成立的原因：$a-b = a + 2^n - b$，如果 $Cout = 1$，则 $a-b>0$，没有借位；反之则有借位。
- 溢出标志 $OF = 1$ 为溢出，只对带符号数有意义，无符号数无意义；下面是几种判断溢出的方法：
   - 根据一位符号位判断：$OverFlow = X_SY_S\overline{F}_S + \overline{X}_S\overline{Y}_SF_S$，$X_S$ 为 $X$ 的符号，$Y_S$ 为 $Y$ 的符号，$F_S$ 为运算结果 $F$ 的符号。补码运算发生溢出只有两种情况，一种是两个正数的结果为负数，另一种是两个负数的结果为正数，分别对应上述的两个式子；
   - 根据进位情况判断：若最高位和次高位的进位不同，则发生了溢出，即 $OverFlow = C_n\oplus C_{n-1}$；
   - 根据双符号位判断：$OverFlow=S_{S1}\oplus S_{S2}$；
      
      采取双符号位，即符号位占两位。符号位 $S_{S1}S_{S2}$各种情况如下：
      1. $S_{S1}S_{S2}=00$：表示结果为正数，无溢出；
      2. $S_{S1}S_{S2}=01$：表示结果正溢出；
      3. $S_{S1}S_{S2}=10$：表示结果负溢出；
      4. $S_{S1}S_{S2}=11$：表示结果为负数，无溢出。
   
      两符号相同时，表示无溢出情况；不同时，表示有溢出，真值符号以最高位符号为准。
- 利用 $A - B$ 对符号位的影响来判断 $A$ 和 $B$ 的大小关系：
  - 无符号数的比较：
    1. $ZF = 1 \rightarrow A = B$；
    2. $ZF = 0, CF = 0\rightarrow A>B$，无借位；
    3. $ZF = 0, CF = 1\rightarrow A<B$，有借位；
  - 带符号数的比较：
    1. $ZF = 1, OF = 0\rightarrow A = B$；
    2. $ZF = 0, OF\oplus SF = 0\rightarrow A>B$；
         >$ZF = 0, OF = 0, SF = 0\rightarrow A>B$,<br>$ZF = 0, OF = 1, SF = 1\rightarrow A>B,$ <br>$a - b = a+[-b]_补$，由 $OF = 1$ 可知结果溢出，那么表示 $a$ 与 $[-b]_补$ 同号并且与结果异号，然而 $SF = 1$，所以 $a$ 与 $[-b]_补$ 的符号位为 $0$，也就是说，在 $SF = OF = 1$ 的情况下，$a$ 必为正，而 $b$ 必为负数或 $0$，在 $ZF = 0$ 的条件下，则有 $A>B$
    3. $ZF = 0, OF\oplus SF = 1\rightarrow A<B$；
         >$ZF = 0, OF = 0, SF = 1\rightarrow A>B$,<br>$ZF = 0, OF = 1, SF = 0\rightarrow A>B,$

#### 3.3.1 原码乘法运算