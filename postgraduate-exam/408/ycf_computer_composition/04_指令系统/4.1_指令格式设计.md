## 4.1 指令格式设计

### 4.1.1 指令地址码的个数

“存储程序”思想：计算机中的程序一旦启动运行，则必须能够自动逐条从主存中取出指令进行执行

因此，一条指令中应包括，操作码（用来确定指令的功能）部分、地址码（用来读取操作需要的数据、以及存储运算的结果）部分、下一条指令的地址；根据指令中地址码个数可以分为

- 三地址指令（两个源操作数地址、一个存结果的地址，例如add操作）
- 二地址指令（两个源操作数地址，结果存到默认的寄存器中）
- 一地址指令（如果为单目运算指令，则其地址既是源操作数地址也是结果地址，如果为双目运算指令，则其地址为源操作数的地址，另一个源操作数有可能存储在累加器中）
- 零地址指令（无需操作数的地址，例如空操作指令、停机指令，对于栈型指令，由于操作数默认在栈中，所以也是零地址指令）

### 4.1.2 指令设计原则

指令应尽量短（降低空间开销）、要有足够的操作码位数（考虑向后兼容）、指令的编码必须有唯一的解释、指令长度应为字节的整数倍（便于指令的读取和地址的计算）、合理选择地址码个数



## 4.2 指令系统设计

四大基本原则：完备性/完整性；兼容性（向后兼容）；均匀性；可扩充性（操作码预留一定的空间）

### 4.2.1 操作数的类型

运算指令能对哪几种数据类型进行操作？

一个程序是由许多条指令组成，从高级语言程序所用数据类型来看，指令涉及的基本操作类型应包括指针或地址、数值数据、位、位串、字符和字符串、逻辑（布尔）数据

### 4.2.2 寻址方式

如何设计寻址方式的种类和编码、各种寻址方式下有效地址如何计算？

- 寻址方式字段可以和操作码一起编码，由操作码确定每个操作数的寻址方式。例如，MIPS体系结构，由操作码确定寻址方式，指令类型确定之后，每个操作数的寻址方式也就确定了
- 寻址方式字段也可单独编码。例如，IA-32指令中每个操作数都有各自专门的寻址方式字段

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20230927112406803.png" alt="image-20230927112406803" style="zoom: 80%;" />

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20230927112433008.png" alt="image-20230927112433008" style="zoom:80%;" />

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20230927112502484.png" alt="image-20230927112502484" style="zoom:80%;" />

### 4.2.3 操作类型

 指令系统中应该有哪些指令？这些指令分为哪些类型？

- 数据传送指令。MOV、LOAD、STORE……
- 算术运算类指令。ADD、SUB、CMP……
- 移位指令。算术移位、逻辑移位、循环移位……
- 转移指令。JMP、BRANCH、CALL、RET、TRAP……
- 输入输出操作。

### 4.2.4 操作码编码

指令有定长指令和变长指令之分，指令中的操作码也有定长操作码和变长操作码之分。CISC采用变长操作码、变长指令码，可以用Huffman编码方式来达到最低平均编码长度；RISC采用定长操作码、定长指令码；也有的系统采用变长操作码、定长指令码设计，一般采用扩展操作码来实现设计

例题，现有8条指令，各指令的使用频率为0.3、0.27、0.23、0.08、0.06、0.04、0.02

- **使用定长操作码设计**

  - 7条指令，需3位进行表示，平均码长H = 4

    | 频率 | 0.3  | 0.27 | 0.23 | 0.08 | 0.06 | 0.04 | 0.02 |
    | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
    | 编码 | 000  | 001  | 010  | 011  | 100  | 101  | 110  |

  - 优点：操作码构造简单；硬件设计简单；译码速度快

  - 缺点：操作码占的存储空间大；指令规模扩充受限

- 使用**Huffman编码**进行设计

  - 编码过程（略）

    | 频率 | 0.3  | 0.27 | 0.23 | 0.08 | 0.06 | 0.04  | 0.02  |
    | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ----- |
    | 编码 | 11   | 10   | 01   | 001  | 0001 | 00001 | 00000 |

  - 平均编码长度H =（0.3 + 0.27 + 0.23）X 2 + 0.08 X 3 + 0.06 X 4 +（0.04 + 0.01）X 5 = 2.23

  - Huffman**编码不唯一**（0、1对换；合并次序），但Huffman编码的**平均码长**是**唯一**的

  - 操作码的编码种类较多，控制器译码的时候比较麻烦，在设计变长操作码时，要求平均编码长度要尽可能最优，但同时也要求编码长度的种类不能太多，编码长度的种类太多会导致控制器的设计比较复杂，因此，一般采用扩展操作码的方法

- **扩展操作码**

  - 根据各指令使用频率的特点，可以将7条指令分为两组，大概率3条，小概率4条，大概率的使用短码编码、小概率的使用长码编码，先对短码进行编码，$2^x > 3$（不能为=，短码不能为长码的前缀，如果=，则短码必为长码的前缀），$x = 2$，$(2^2 - 3) * 2^y \ge 4$，$y = 2$，由此可以得到编码结果：

    | 频率 | 0.3  | 0.27 | 0.23 | 0.08 | 0.06 | 0.04 | 0.02 |
    | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
    | 编码 | 00   | 01   | 10   | 1100 | 1101 | 1110 | 1111 |

  - 平均编码长度H =（0.3 + 0.27 + 0.23）X 2 +（0.08 + 0.06 + 0.04 + 0.02）X 4 = 2.4

### 4.2.5 标志信息的生成和使用

（见运算方法和运算部件）ZF、OF、SF、CF什么时候为0，什么时候为1

### 4.2.6 指令系统设计风格

- 按操作数位置指定风格来分

  | 系统                 | 特点                                                         |
  | -------------------- | ------------------------------------------------------------ |
  | 累加器型指令系统     | - 将一个操作数隐含在累加器（AC）中，执行结果也送累加器<br />- 指令字短，但每次运算都要经过累加器（现已不用） |
  | 栈型指令系统         | - Java虚拟机中使用，通用计算器中很少使用<br />- 指令字很短，但操作数只能来自栈顶 |
  | 通用寄存器型指令系统 | - 使用通用寄存器来存放运算过程中所用的临时数据<br />- 占主导地位 |
  | Load/Store型指令系统 | - 通用寄存器型指令系统的一种<br />- 只有Load和Store指令才可访问内存 |

- 按指令格式的复杂度来分

  | 系统                                   | 特点                                                         |
  | -------------------------------------- | ------------------------------------------------------------ |
  | CISC(Complex Instruction Set Computer) | - 指令系统复杂。指令多，寻址方式多，指令格式多<br />- 指令周期长，指令周期差距大<br />- 可以访存的指令不受限制，各种指令的使用频率差距很大<br />- 控制器大多采用微程序控制<br />- 难以进行编译优化 |
  | RISC(Reduced Instruction Set Computer) | - 指令格式规整。寻址方式少，指令格式少，指令长度已知<br />- 指令数目少。只包含使用频度高的简单指令<br />- 采用Load/Store型指令设计风格<br />- 采用流水线方式执行指令<br />- 尽量使用RR型指令，CPU中通用寄存器相当多<br />- 控制器大多采用硬布线控制，特别注重编译优化 |



## 4.3 程序的机器级代码表示

### 4.3.1 汇编指令基础

- **相关寄存器**

  <img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231009135111260.png" alt="image-20231009135111260" style="zoom:80%;" />

  - 调用者保存寄存器（被调用者可以直接使用）：EAX、ECX、EDX
  - 被调用者保存寄存器（被调用者需要将寄存器内容保存之后才能使用）：EBX、ESI、EDI
  - 每个过程被调用时都会在堆栈中生成自己的栈区，称为栈帧，当前正在执行的程序的栈帧在栈的最上面，当前栈帧的范围在栈指针EBP（Base Pointer）和ESP（Stack Pointer）指向的区域之间

### 4.3.2过程调用的机器级表示

过程P（调用者）调用过程Q（被调用者）的执行步骤：

- P将入口参数（实参）放在Q能访问到的地方
- P将返回地址存到特定的地方，然后将控制转移到Q
- Q保存P的现场，并为自己的非静态局部变量分配空间
- 执行过程P
- Q恢复P的现场，将返回结果放到P能访问到的地方，并释放局部变量所占空间
- Q取出返回地址，将控制转移给P

```c
int add(int x, int y) {
-------------------------------------------------
add:
push ebp
mov ebp esp
-------------------------------------------------
	return x + y;
-------------------------------------------------
mov eax,dword ptr [ebp+12]
mov edx,dword ptr [ebp+8]
lea eax,[edx+eax]
leave
ret
-------------------------------------------------
}

int caller() {
--------------------------------------------------
caller:
push ebp		// 上一个过程的ebp压栈
mov ebp, esp	// 将栈顶作为当前栈帧的ebp（栈底）
--------------------------------------------------
	int temp1 = 125;
	int temp2 = 80;
	int sum = add(temp1, temp2);
-------------------------------------------------
sub esp,24
mov [ebp-12],125	// 按照先出现的元素靠近栈顶的顺序存储数据
mov [ebp-8],80		// 虽然sum没有初始化，但仍要给sum留一个位置
mov eax,dword ptr [ebp-8]	// 按照入口参数，从右至左依次将temp2和temp1的值压入栈中
mov [esp+4],eax				// mov指令不能两个值都在内存中
mov eax,dword ptr [ebp-12]	// 所以先将数据读取到eax中，再将eax中读取的数据存到待存的地方
mov [esp],eax
call add		// 将IP压栈保存（因为是压栈，所以是保存在当前栈帧的顶部）
mov [ebp-4],eax	// 将返回值送sum
-------------------------------------------------
	return sum;
-------------------------------------------------
mov eax,dword ptr [ebp-4]	// 返回sum
leave
ret
-------------------------------------------------
}
```

- `call`指令的作用：
  - 将IP(PC)旧值压栈保存（保存在函数的栈帧顶部）
  - 设置IP新值，无条件转移至被调用函数的第一条指令
- `ret`指令的作用：从函数的栈帧顶部找到IP旧值，将其出栈并恢复IP寄存器
- `enter`指令：`push ebp`、` mov ebp,esp`
- `leave`指令：`mov esp,ebp`、`pop ebp`
- `lea`指令：`lea eax,[edx + eax*2 + 8]` = `R[edx] + R[eax]*2 + 8 --→ R[eax] `
- 如何访问栈帧数据？
  - push a（esp - 4，esp=a）、pop b（b = esp，esp + 4）
  - move指令结合esp、ebp，注意move的两个操作数不能都为读取主存内容

|                   一个栈帧中可能包含的内容                   | `add`函数执行到`leave`指令时的栈帧所包含的内容 |
| :----------------------------------------------------------: | :--------------------------------------------: |
|                              ……                              |                       ……                       |
|                    上一层栈帧基址（ebp）                     |             上一层栈帧基址（ebp）              |
|                        若干个局部变量                        |        sum<br />temp2=20<br />temp1=125        |
| 未使用的区域（GCC为保证数据的严格对齐规定每个函数的栈帧大小必须是16字节的倍数，这个区域可以看作是为了用来凑16字节的倍数的） |                为了凑数分配了4B                |
|                部分寄存器值（eax、ecx、edx）                 |                 （未分配空间）                 |
|                        若干个调用参数                        |                  80<br />125                   |
|                         IP(返回地址)                         |                    返回地址                    |
|                              ……                              |                       ……                       |

### 4.3.3 选择语句的机器级代码表示

```c
int get_cont(int *p1, int *p2) {
    if (p1 > p2) return *p2;
    else return *p1;
}

--------------------------------------
AT&T汇编：											  x86汇编：					   if翻译成goto的形式：
movl 8(%ebp), %eax									mov eax, dword ptr [ebp+8]
movl 12(%ebp), %edx									mov edx, dword ptr[ebp+12]
cmpl %edx, %eax		// 比较p1、p2,根据p1-p2的结果置标志 cmp eax, edx					t = test_expr;
jbe .L1				// p1<=p2,则转到标记.L1处执行	   jbe .L1						  if (!t) goto false;
movl (%edx), %eax									mov eax, dword ptr [edx]		then_statement
jmp .L2												jmp .L2							goto done;
.L1:												.L1:							false:
movl (%eax), %eax									mov eax, dword ptr [eax]		then_statement
.L2:												.L2:							done:
--------------------------------------
```

### 4.3.4 循环语句的机器级代码表示

```c
for (init_expr; test_expr; update_expr)		while:	init_expr;
	body_statement									while (test_expr) {
														body_statement
														update_expr;
													}
do-while:					goto:
	init_expr;					init_expr;
	t = test_expr;				t = test_expr;
	if (!t) goto done;			if (!t) goto done;
	do {						loop:
		body_statement				body_statement
		update_expr;				update_expr;
	} while (test_expr);		if (t) goto loop;
	done:						done
```

```
int nsum_for(int n) {
	int sum = 0;
	for (int i = 1; i <= n; i ++)
		sum += i;
	return sum;
}

-----------------------------------------------------------
AT&T汇编：					x86汇编：
movl 8(%ebp), %ecx		  mov ecx, [ebp-8]
movl $0, %eax			  mov eax, 0
movl $1, %edx			  mov edx, 1
cmpl %ecx, %edx			  cmp edx, ecx
jg .L2					  jg .L2			// if greater, 大于时跳转
.L1:					  .L1:
addl %edx, %eax			  add eax, edx
addl $1, $edx			  add edx, 1
cmpl %ecx, %edx			  cmp edx, ecx
jle .L1					  jle .L1			// if less or equal，小于或等于时跳转
.L2:					  .L2:
-----------------------------------------------------------
```

