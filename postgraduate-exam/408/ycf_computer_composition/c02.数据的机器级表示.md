- [2.1 数制和编码](#21-数制和编码)
  - [2.1.1 信息的二进制编码](#211-信息的二进制编码)
  - [2.1.2 进位计数制](#212-进位计数制)
  - [2.1.3 定点与浮点表示](#213-定点与浮点表示)
  - [2.1.4 定点数的编码表示](#214-定点数的编码表示)
- [2.2 整数的表示](#22-整数的表示)
  - [2.2.1 无符号整数的表示](#221-无符号整数的表示)
  - [2.2.2 带符号整数的表示](#222-带符号整数的表示)
  - [2.2.3 $\\text{C}$ 语言中的整数类型](#223-textc-语言中的整数类型)
- [2.3 实数的表示](#23-实数的表示)
  - [2.3.1 浮点数的表示格式](#231-浮点数的表示格式)
  - [2.3.2 浮点数的规格化](#232-浮点数的规格化)
  - [2.3.3 $\\text{IEEE 754}$ 浮点数标准](#233-textieee-754-浮点数标准)
  - [2.3.4 $\\text{C}$ 语言中的浮点数类型](#234-textc-语言中的浮点数类型)
- [2.6 数据的宽度和存储](#26-数据的宽度和存储)
- [2.7 数据校验码](#27-数据校验码)

从计算机指令集体系结构（ISA）角度来看，程序被转化为机器码后，CPU 执行机器码代表的指令对数据进行处理，对指令来说，数据就是一串 0/1 序列，根据指令的不同这串序列有不同的解释。比如，解释为无符号/带符号整数、实数（浮点数）、非数值数据（逻辑值、ASCII码或汉字字符等）。

为了保证数据的准确性，计算机内部也会对数据进行校验，常见的校验方式有奇偶校验、海明校验、循环冗余校验等。

### 2.1 数制和编码

#### 2.1.1 信息的二进制编码

计算机的内部采用的是二进制表示方式，这样做的原因有以下几点：

1. 二进制只有两种基本状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，而制造有两个稳定状态的物理器件要比制造有多个稳定状态的物理器件容易得多。例如，用高、低两个电位，或用脉冲的有无，或脉冲的正负极性等都可以很方便、很可靠地表示 0 和 1；

2. 二进制的编码和运算规则都很简单。可用开关电路实现，简便易行；

3. 两个符号 0 和 1 正好与逻辑命题的两个值“真”和“假”相对应，为计算机中实现逻辑运算和程序中的逻辑判断提供了便利的条件，特别是能通过逻辑门电路方便地实现算术运算。

在计算机内部，数值数据的表示方法有两种：一种是直接用二进制数表示，另一种是采用二进制编码的十进制数 (Binary Coded Decimal Number, BCD) 表示。可以通过以下三个要素确定一个数值数据：进位计数制、定点/浮点表示和编码规则。

#### 2.1.2 进位计数制

在书写时，可以使用后缀字母表示该数的进位计数制，一般用 B(Binary) 表示二进制，用 O(Octal) 表示八进制，用 D(Decimal) 表示；用 H(Hexadecimal) 表示十，有时也用 0x 表示十六进制。

知道不同进制之间的转换方法：

- 十进制转 R 进制：
  - 整数部分：“除基取余，上右下左”
  - 小数部分：“乘基取整，上左下右”

- R 进制转十进制：按位展开；

- 二、八、十六进制之间的互相转换；

#### 2.1.3 定点与浮点表示

日常生活中使用的数有整数和实数之分，整数的小数点固定在数的最右边，实数的小数点不固定。因此，计算机中有两种数据格式：定点表示和浮点表示。
- 定点表示法可用来表示定点小数和定点整数（整数）。定点小数的小数点固定在数的最左边，一般用来表示浮点数的尾数部分。
- 浮点表示法可将一个二进制数表示为以下形式，
  $$
  X = (-1)^S·M·R^E
  $$
  - $\text{S(Signal)}$ 为 $X$ 的符号，$0$ 为正，$1$ 为负；
  - $\text{M(Mantissa)}$ 为 $X$ 的尾数；
  - $\text{E(Exponent)}$ 为 $X$ 的阶；
  - $\text{R(Radix)}$ 为 $X$ 的基数；

#### 2.1.4 定点数的编码表示

可以用一组 $S,M,R,E$ 唯一确定一个浮点数，$S$ 用一个 $\text{bit}$ 就可表示，而$M,R,E$ 都可以用定点数进行表示，所以，只需要考虑定点数的编码即可。

定点数编码表示方法主要有以下四种：原码、补码、反码和移码。通常将数值数据在计算机内部编码表示的二进制数称为机器数，而机器数真正的值称为机器数的真值。对于同一机器数用不同的编码方式进行解释可得到不同的真值。

1. 原码表示法：机器数的最高位表示数的符号，其余各位表示数的绝对值。在原码表示法中，正数和负数的编码表示只有符号位不同，数值部分完全相同。
   - 正数：$[x]_原 = 0X_{n-2}···X_0$，负数：$[x]_原 = 1X_{n-2}···X_0$；
      >机器数为 $n$ 位
   - 优点：直观、方便，和真值的转换计算简单。
   - 缺点：0的表示不唯一；原码不支持符号扩展；加减运算繁琐。（思考：为什么繁琐？）
   - 对于 $n$ 位原码，其表示的整数的范围是：$[-2^{n-1}+1, 2^{n-1}-1]$。其中，$0$ 会出现两次。
2. 补码表示法：补码表示法可以实现加减运算的统一，即用加法来实现减法。补码表示法也称为 “$2-$补码” $\text{(two's complement)}$ 表示法，由符号位后跟真值模 $2^n$ 构成。

    在一个模运算系统中，一个数与它除以 “模” 后得到的余数是等价的；并且，负数等价于 “模” 加上该负数。比如在一个钟表系统中，模为 $12$，倒拨 $4$ 格等于正拨 $8$ 格，$10-4 = 10+(12-4)=6$。

    计算机中的补码表示相当于一个模 $2^n$ 的系统，令 $M = 2^n$，
    - 当 $X_T$ 为正数时，$[X_T]_补 = X_T = M+X_T\text{ (mod M)}$
    - 当 $X_T$ 为负数时，$[X_T]_补 = M + X_T\text{ (mod M)}$
    
    综上，对于任意一个数 $X_T$，$[X_T]_补 = M + X_T\text{ (mod M)}$

    - 优缺：$0$ 的表示唯一；加减运算方便；支持符号扩展；补码转换为真值较繁琐；
    - $n$ 位补码的范围：$[-2^{n-1}, 2^{n-1}-1]$；

    - 原码-补码转换方法：对于正数，原码即为补码；对于负数，找出原码表示下最低位的 $1$，从该位开始，将比该位“高” 的所有数值位翻转，该位及比该位“低”的所有数值位保持不变，即可实现原码-补码互相转换；

    - 相反数补码转换技巧：若想将某数 $x$ 的补码表示法转变为 $-x$ 的补码表示，找出最低位的 $1$，从该位开始，将比该位 “高” 的所有位反转，该位及比该位“低”的所有位保持不变，即可实现相反数的互相转换；
      >注意：对于 $n$ 位补码，$-2^{n-1}$ 具有补码表示，但是 $2^{n-1}$ 没有！


3. 反码表示法：负数的补码可采用 “各位取反，末尾+1” 的方法得到，如果仅各位取反而没有加1，那么即可得到负数的反码表示。
   - 缺点：$0$ 的表示不唯一；运算时必须考虑循环进位；
   - 反码和补码的出现是为了更好的表示负数，正数的反码和补码与原码相同；
4. 移码表示法：$[E]_移 = 2^{n-1}+E$，$2^{n-1}$ 为偏置常数。移码主要用来表示浮点数的指数，因此，移码只用来表示定点整数。为什么要用移码表示浮点数的指数呢？
    >当两个浮点数进行运算时，必须先 “对阶”（即比较两个数的阶的大小并使之相等）。为简化比较操作，使操作过程不涉及指数的符号，对每个指数都加上一个常数，使所有指数都转换为正整数，这个常数称为偏置常数。
    - 对于 $n$ 位移码，其能表示的整数范围为 $[-2^{n-1},2^{n-1}-1]$；
    - 移码 $0$ 的真值为 $-2^{n-1}$，真值 $0$ 的移码表示是唯一的；
      $$[-2^{n-1}]_移=00..00\text{ (n 个 0 )}\\
      [+0]_移=[-0]_移=10...00\text{ (n-1 个 0) }
      $$

### 2.2 整数的表示

计算机中处理的整数可以用二进制表示，也可以用二进制编码的十进制数（$\text{BCD}$ 码）表示。二进制整数分为无符号整数和带符号整数两种。 

#### 2.2.1 无符号整数的表示

当一个编码的所有二进位都用来表示数值而没有符号位时，该编码表示的就是无符号整数。此时，默认数的符号为正，所以无符号整数就是正整数或非负整数。

一般在全部是正数运算且不出现负值结果的场合下，使用无符号整数表示。例如，可用无符号整数进行地址运算，或用来表示指针。通常把无符号整数简单地说成无符号数。

$n$ 位无符号数可表示的数的范围：$[0,2^n-1]$。


#### 2.2.2 带符号整数的表示

带符号整数也称为有符号整数，它必须用一个二进位来表示符号，虽然前面介绍的各种进制定点数编码表示 (包括原码、补码、反码和移码) 都可以用来表示带符号整数，但是补码表示有其突出的优点，主要体现在以下几方面：
1. 数0的补码表示形式唯一；
2. 补码运算规则简单：可以用加法实现减法运算；符号位可以和数值位一起参加运算；
3. 相比原码和反码，补码可以多表示一个最小负数；

现代计算机中带符号整数都用补码表示。$n$ 位带符号数可表示的数值范围为 $[-2^{n-1}, 2^{n-1}-1]$

#### 2.2.3 $\text{C}$ 语言中的整数类型
|整数数据类型|字节数|范围|
|---|---|---|
| $\text{char}$| $\text{1}$|$[0,255]$ |
| $\text{short}$| $\text{2}$|$[-2^{15},2^{15}-1]$ |
| $\text{unsigned short}$| $\text{2}$|$[0,2^{16}-1]$ |
| $\text{int}$| $\text{4}$|$[-2^{31},2^{31}-1]$ |
| $\text{unsigned int}$| $\text{4}$|$[0,2^{32}-1]$ |

$\text{C}$ 语言中允许无符号整数和带符号整数之间的转换，转换后的真值是将原二进制机器数按转换后的数据类型重新解释得到的。长度相同的类型转换，不会改变计算机内部存储的数值，只改变解释方式；长度不同的类型转换如下，
- 短向长的转换，需要先进行符号扩展，再按转换后的数据类型进行解释；
- 长向短的转换，高位截断，低位保留，再按转换后的数据类型进行解释；

需要注意的是，在 $\text{C}$ 语言中，如果一个运算同时有无符号数和带符号整数参加，那么，$\text{C}$ 编译器会隐含地将带符号数强制类型转换为无符号数，因而产生一些意想不到的结果。


### 2.3 实数的表示

对于 $n$ 位带符号整数，表示范围为 $[-2^{n-1}, 2^{n-1}-1]$，计算机中的 $n$ 是有限的，因此，带符号整数（补码表示法）很容易溢出；此外，整数表示法无法表示带有小数点的实数。因此，计算机中专门用浮点数来表示实数。

#### 2.3.1 浮点数的表示格式

浮点表示法可将一个二进制数表示为以下形式，
  $$
  X = (-1)^S·M·R^E
  $$
  - $\text{S(Signal)}$ 为 $X$ 的符号，$0$ 为正，$1$ 为负；用 $\text{1 bit}$ 即可表示；
  - $\text{M(Mantissa)}$ 为 $X$ 的尾数；一般用定点原码小数表示；
  - $\text{E(Exponent)}$ 为 $X$ 的阶；一般用移码表示；
  - $\text{R(Radix)}$ 为 $X$ 的基数；基数一般为默认值；

在 $\text{IEEE 754}$ 浮点数标准被广泛使用之前，不同计算机的浮点数表示格式各不相同，我们只讨论 $\text{IEEE 754}$ 浮点数标准。

#### 2.3.2 浮点数的规格化

浮点数的规格化操作有两种，左规和右规
1. 左规：当运算结果的尾数最高数位为 $0$ 时，需要进行左规。左规时，尾数每左移一次，阶码减1。左规可能进行多次。

   $0.0001 \text{ 左规 } 0.1·10^{-3}$

2. 右规：当运算结果的尾数有效位进到小数点前面时，需要进行右规。右规时，尾数每右移一次，阶码加1.右规最多进行一次。

   $101.0001 \text{ 右规 } 0.1010001^{3}$

思考：为什么要进行规格化？提示：精度、唯一性；

#### 2.3.3 $\text{IEEE 754}$ 浮点数标准

该标准提供了两种基本浮点格式：$32$ 位单精度（短浮点数、$\text{float}$ ）和 $64$ 位双精度（长浮点数、$\text{double}$ ）格式，基数默认为 $2$。$32$ 位单精度格式中的 $\text{S, E, M}$ 分别占 $\text{1, 8, 23}$ 位；$64$ 位双精度格式中的 $\text{S, E, M}$ 分别占 $\text{1, 11, 52}$ 位，如下图所示：

<img src='./img/图2-1 IEEE 754 浮点数格式.png' />

注意：$\text{IEEE 754}$ 浮点数标准的特殊做法 “尾数带一个隐藏位，偏置常数为 $2^{n-1}-1$”。这种做法不仅没有改变传统做法的计算结果，而且带来了以下两个好处：
- 尾数可表示的位数多一位，因而使浮点数的精度更高；
- 指数的可表示范围更大，因而使浮点数的范围更大；

在浮点数标准中，存储的是规格化后的尾数，尾数用原码表示，第一位总为 $1$，因而可在尾数中省略第一位的 $1$，该位称为隐藏位，使得单精度格式的 $23$ 位尾数实际上可表示 $24$ 位有效数字；双精度格式的 $52$ 位尾数实际上可表示 $53$ 位有效数字。$\text{IEEE 754}$ 浮点数标准规定隐藏位 $1$ 的位置在小数点之前。

浮点数的阶码一般用移码表示，移码的偏置常数一般为 $2^{n-1}$，而 $\text{IEEE 754}$ 浮点数标准中阶码的偏置常数为 $2^{n-1}-1$，故单精度和双精度浮点数的偏置常数分别为 $127$ 和 $1023$。

下表是 $32$ 位的 $\text{IEEE 754}$ 浮点数标准中规定的数，$64$ 位的标准也类似：

|值的类型|S（符号）|E（阶码）|M（尾数）|值|
|---|---|---|---|---|
|正零|$0$ |$0$ |$0$ |$0$ |
|负零|$1$ |$0$ |$0$ |$-0$ |
|正无穷大|$0$ |$255\text{ (全 1)}$  |$0$ |$+\infin$ |
|负无穷大|$1$ |$255\text{ (全 1)}$ |$0$ |$-\infin$ |
|无定义数|$0\text{ 或 } 1$ |$255\text{ (全 1)}$ |$\neq 0$ |$\text{NAN}$ |
|规格化非零正数|$0$ |$0<e<255$ |$f$ |$2^{e-127}(1.f)$ |
|规格化非零负数|$1$ |$0<e<255$ |$f$ |$-2^{e-127}(1.f)$ |
|非规格化正数|$0$ |$0$ |$f\neq 0$ |$2^{-126}(0.f)$ |
|非规格化负数|$1$ |$0$ |$f\neq 0$ |$-2^{-126}(0.f)$ |

<img src='./img/图2-2 单精度浮点数的二进制表示.png' />


<img src='./img/图2-3 非负浮点数格式总结.png' />


#### 2.3.4 $\text{C}$ 语言中的浮点数类型

1. $\text{float}$ 和 $\text{double}$ 分别对应 $\text{IEEE 754}$ 单精度和双精度浮点数；

2. $\text{int}$ 转换为 $\text{float}$：范围提升，精度下降。（ $\text{int}$ 有效位数 $31$ 位，$\text{float}$ 有效位数 $24$ 位）；
3. $\text{int/float}$ 转换为 $\text{double}$：范围提升，精度提升；
4. $\text{double}$ 转换为 $\text{float}$：范围下降，精度下降；
5. $\text{float}$ 转换为 $\text{int}$：范围下降，精度可能会下降（因为 $\text{int}$ 没有小数部分，只保留整数）

判断：$(d + f)-d == f$ 是否为真，$d$ 为 $\text{double}$，$f$ 为 $\text{float}$。

解析：当 $d = 1.79·10^{308},\,\,f=1.0$ 时，左边为 $0$，因为 $d + f$ 时，$f$ 需向 $d$ 对阶，对阶后 $f$ 的尾数中的有效位被摄取而变为 $0$，故 $d+f$ 仍然为 $d$，再减去 $d$ 后结果为 $0$，而右边为 $1$。

### 2.6 数据的宽度和存储


### 2.7 数据校验码