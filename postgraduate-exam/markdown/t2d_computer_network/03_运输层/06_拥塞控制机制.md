## 3.6 拥塞控制原理

### 3.6.1 拥塞原因及代价



### 3.6.2 拥塞控制方法

- 端到端拥塞控制方法：当网络层没有为运输层的拥塞控制提供显示支持时，只能使用端到端的拥塞控制方法。通过超时或收到3次冗余ACK来推测当前网络已堵塞；通过收到新的ACK来推测当前网络畅通；TCP采用端到端的控制方法来实现拥塞控制，因为网络层一般不为拥塞控制提供显示支持；
- 网络辅助拥塞控制方法：网络层为运输层的拥塞控制提供显示支持。对于网络辅助的拥塞控制方式，拥塞信息从网络反馈到发送方通常有两种方式：直接网络反馈；经由接收方的网络反馈；



## 3.7 TCP拥塞控制

TCP的拥塞控制通过在发送方维护拥塞窗口(congestion window, cwnd)实现，在发送方中需确保未被确认的数据量不会超过cwnd和rwnd(receive window)的最小值，即`LastByteSent - LastByteAcked <= min{cwnd, rwnd}`，端到端的拥塞控制是通过超时、收到3次冗余ACK或收到新的ACK来推测网络是否拥堵的，因此，cwnd的更新也取决于这三种情况，假设初始时cwnd = 1MSS、ssthresh(慢启动阈值) = 64KB、dupACKcount = 0，此时处于慢启动状态；

- **慢启动状态**：

  - 每当收到一个**new ACK**，cwnd += MSS，将dupACKcount置零，如果条件允许，则发送一个新的分组；

  - **超时**事件发生时，ssthresh(慢启动阈值) = cwnd/2、cwnd = 1MSS，将dupACKcount置零，重传丢失的分组；

  - 收到**重复的ACK**时，dupACKcount++，当**dupACKcount = 3**时，将ssthresh = cwnd/2、cwnd = ssthresh + 3MSS，重传丢失的分组，转到快速恢复状态；

    > 《自顶向下》收到三个重复的ACK后，cwnd更新为ssthresh + 3MSS，而408中cwnd更新为ssthresh

  - 当**cwnd >= ssthresh**，转到拥塞避免状态；

    > 初始的ssthresh的值一般设置的很大，只有当出现超时或收到三个重复的ACK时才会更新ssthresh(慢启动阈值)，
    >
    > 可以将超时理解为当前的网络拥塞很严重，所以每次超时都要将cwnd置为1MSS，慢启动阈值变为cwnd的一半是为了防止cwnd再次变为超时时的cwnd；
    >
    > 将收到三个重复的ACK理解为普通的网络拥塞，cwnd变为ssthresh+3MSS，而不是直接减到1MSS，会变为cwnd/2(因为慢启动状态的cwnd每次更新都是乘2)，即当前的拥塞窗口太大，导致了分组丢失，需要限制窗口的值低于当前窗口；cwnd >= ssthresh说明当前窗口值离上次分组丢失的窗口值已经很近了，需要减缓cwnd的增长速度；

- **拥塞避免状态**：

  - 每当收到一个new ACK，cwnd += MSS(MSS/cwnd)，将dupACKcount置零，如果条件允许，则发送一个新的分组；

    > 处于拥塞避免状态时，需要减缓cwnd的增长速度，在每个RTT内cwnd只加一个MSS(处于慢启动时，一个RTT时间cwnd可以翻倍)，因此cwnd += MSS(MSS/cwnd)，即每次收到一个新的ACK时，cwnd只增加(MSS/cwnd)个MSS

  - **超时**事件发生时，ssthresh(慢启动阈值) = cwnd/2、cwnd = 1MSS，将dupACKcount置零，重传丢失的分组，转到慢启动状态；

  - 收到**重复的ACK**时，dupACKcount++，当**dupACKcount = 3**时，将ssthresh = cwnd/2、cwnd = ssthresh + 3MSS，重传丢失的分组，转到快速恢复状态；

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231025152841478.png" alt="image-20231025152841478" style="zoom:67%;" />

> 例子：处于拥塞避免阶段时，如果MSS = 1460B、cwnd = 14600B，则在一个RTT内可发送10个报文段，对于每个到达的ACK、cwnd += 1/10MSS
>
> 如果是处于慢启动阶段，对于每个到达的ACK，cwnd += MSS，这是个报文段是同时发送的，所以在一个RTT，cwnd可以翻倍

