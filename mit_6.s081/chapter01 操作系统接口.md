
- [一、操作系统接口](#一操作系统接口)
  - [1.1 进程和内存](#11-进程和内存)
  - [1.2 I/O 和文件描述符](#12-io-和文件描述符)
  - [1.3 管道](#13-管道)
  - [1.4 文件系统](#14-文件系统)
  - [1.5 真实的世界](#15-真实的世界)

## 一、操作系统接口


操作系统的工作：
- 让多个程序共享计算机资源并给程序提供一系列比硬件本身更有用的服务；
- 管理并抽象化底层硬件。例如，字处理软件不需要关心自己使用的是哪种类型的硬盘；
- 让多个程序之间共享硬件，使得多个程序（至少看起来）是同时运行的；
- 最后，给程序间提供一种受控的交互方式，让它们能够共享数据、协同工作；

操作系统通过接口向用户程序提供服务。一个好的接口往往是很难设计的，一方面，我们希望接口的功能简单且有限(simple and narrow)，使其易于正确的实现；另一方面，我们想要使用接口为应用提供较复杂的功能。解决这种矛盾的方法是：让接口只依赖少量的机制（mechanism），然后通过这些机制的组合提供强大、通用的功能。

本书通过 xv6 操作系统来说明操作系统的概念。xv6 提供 Unix 中的基本接口（由 Ken Thompson 和 Dennis Ritchie 引入），同时模仿 Unix 的内部设计。Unix 里机制结合良好的窄接口提供了令人吃惊的通用性。这样的接口设计非常成功，使得包括 BSD，Linux，Mac OS X，Solaris （甚至 Microsoft Windows 在某种程度上）都有类似 Unix 的接口。理解 xv6 是理解这些操作系统的一个良好起点。

如 Figure 1.1 所示，xv6 使用了传统的内核（一个向其它运行中的程序提供服务的程序）概念。每一个运行着的程序称为一个进程，进程有专门的内存空间，用来存储指令、数据和栈。指令实现程序的运算，数据是运算过程所需的变量，栈用于管理程序的过程调用。

<img src='./img/图1.1 a kernel and two user processes.png' />

进程通过系统调用使用内核服务，系统调用是操作系统的接口。系统调用会进入内核，让内核执行服务然后返回。因此，进程总是在用户空间和内核空间之间交替运行。

正如后面章节中提到的，内核使用 CPU 提供的硬件保护机制来确保进程在用户空间执行时只能访问自己的内存空间。内核拥有实现保护机制所需的硬件权限；用户程序没有。当用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。

内核提供的一系列系统调用就是用户程序可见的操作系统接口。xv6 内核提供了 Unix 传统系统调用的一部分，如图 Figure 1.2。

<img src='./img/图1.2 xv6 system calls.png' />

本章的剩余内容 xv6 系统服务的概貌——进程、内存、文件描述符、管道和文件系统，我们通过一些代码片段以及 shell（Unix 的命令行用户界面）是如何使用这些代码片段的来介绍上述内容。这些系统调用在 shell 上的应用阐释了他们的设计是多么的独具匠心。

shell 是一个普通的程序，它从用户那里读取命令并执行。实际上，shell 是一个用户程序，它不是内核的一部分，由此展示了系统调用接口的强大：shell 的实现并没有什么特殊的地方。这意味着 shell 很容易被替代；因此，现代 Unix 系统有各种各种的 shell 可以选择，每一个都有它自己的用户界面和脚本特点。xv6 shell 是 Unix Bourne shell 的简易版本，它的实现代码可以在 [(user/sh.c:1)](https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L1) 中找到。

### 1.1 进程和内存

一个 xv6 进程由两部分组成，一部分是用户内存空间（指令、数据和栈），另一部分是仅对内核可见的进程状态。xv6 为进程的执行提供了时分特性：在等待执行的进程中透明的切换可用的 CPU。当一个进程停止执行时，xv6 会保存进程的 CPU 寄存器的状态，在下一次执行这个进程时恢复寄存器中的内容。对于每个进程，内核中有一个进程标识符(process identifier, PID) 与之关联。

进程可以使用 `fork` 创建新的进程。`fork` 创建的新进程称为子进程，子进程的内存中的内容与创建它的进程（父进程）的内容相同。`fork` 在父进程和子进程中都会有返回值。在父进程中，`fork` 返回子进程的 PID；在子进程中，`fork` 返回 0。考虑下面的 C 语言代码：
```c
#include <stdio.h>    // 提供了 printf() 函数的声明
#include <unistd.h>   // 提供了 fork() 和 exit() 函数的声明
#include <sys/wait.h>  // 提供了 wait() 函数的声明
#include <stdlib.h>   // 提供了 exit() 函数的声明

int
main() {
    int pid;
    pid = fork();
    if(pid > 0){
        printf("parent: child=%d\n", pid);
        pid = wait(0);
        printf("child %d is done\n", pid);
    } else if(pid == 0){
        printf("child: exiting\n");
        exit(0);
    } else {
        printf("fork error\n");
    }

}

```
系统调用 `exit` 会导致调用它的进程停止执行并释放资源（例如内存和打开的文件），`exit` 使用一个整形的状态参数，一般来说 0 表示成功，1 表示失败。

系统调用 `wait` 的参数为一个地址，它会返回当前进程的已退出的子进程（或杀死的进程）的 PID 并通过 `wait` 中的地址参数来传递子进程的退出状态；`wait` 会一直等待直到有调用者的子进程退出，如果调用者没有子进程，`wait` 会马上返回 -1。如果父进程不关心子进程的退出状态，它可以向 `wait` 传入一个 0 地址；上面代码的输出如下：
```
parent: child=1234
child: exiting
```
结果的输出的顺序有可能会不同（甚至混合），取决于父进程和子进程谁先调用 `printf`。子进程退出后，父进程的 `wait` 返回，父进程输出下面内容，
```
parent: child 1234 is done
```
尽管在父进程和子进程在刚开始时内存中有相同的内容，但是父进程和子进程在执行时会使用独立的内存空间和寄存器：改变其中一个进程中的变量不会影响另一个进程中的变量。例如，当 `wait` 的返回值存储到父进程的 `pid` 中后，子进程的 `pid` 的值仍为 0。

系统调用 `exec` 从某个文件（通常是可执行文件）里读取内存镜像，然后将其替换到调用它的进程的内存空间。该文件必须符合特定的格式，需要指出了哪一部分存储了指令，哪一部分存储了数据以及从何处开始执行指令等等。xv6 使用 ELF 文件格式，在[第三章]()中会给出更多内容。一般来说这个文件中存储的是源代码编译后的结果。当 `exec` 成功执行后，它不返回调用它的程序，相反，它从 ELF 头部中定义的入口点处开始加载指令执行。`exec` 需要两个参数：可执行文件的文件名和一个字符串数组。例如，
```c
char *argv[3];

argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```

这段程序将调用程序替换为参数列表为 `echo hello` 的 `/bin/echo` 程序。大部分程序忽略参数数组的第一个元素，它一般用来存储程序的名字。

xv6 shell 使用以上调用来为用户运行程序。shell 的主要结构很简单；代码见[(user/sh.c:146)](https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L146)。主循环使用 `getcmd` 从命令行读取输入。然后调用 `fork`，创建 shell 进程的副本。当子进程运行用户命令时，父进程调用 `wait`。例如，如果用户在 shell 中输入 `echo hello`，子进程会调用`runcmd`，并将 `echo hello` 作为它的参数，`runcmd`[(user/sh.c:55)](https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L55) 中会运行实际的命令。对于 `echo hello`，`runcmd` 中将会调用 `exec`，`exec` 成功执行后子进程会转到 `echo` 中执行指令，而不是返回 `runcmd`。`echo` 将会在某个时间点调用 `exit`，使父程序从 `wait` 中返回。

既然一个程序 `fork` 后是为了 `exec` 另一个程序，为什么 不将 `fork` 和 `exec` 组合成一个系统调用？下一节中我们将会看到利用这个分离的特性来实现 I/O 的重定位。为了避免创建一个重复的进程然后马上用其它程序来替换它（用 `exec`）所造成的浪费，操作系统内核会通过使用虚拟内存技术，例如写时复制（copy-on-write）（见4.6节）针对这种用例优化 `fork` 的实现。

xv6 隐式的分配大部分的用户内存空间：`fork` 分配了子进程所需的父进程的内存副本的空间，`exec` 也分配了足够的内存来存储可执行文件。进程在运行时所需要的内存（可能是调用了 `malloc`）可以通过调用 `sbrk(n)` 来使它的数据内存增加 n 个字节；`sbrk` 将会返回新内存的地址。

### 1.2 I/O 和文件描述符

文件描述符是一个小的整型数据，它代表了一个进程可以读写的被内核管理的对象。进程可以通过多种方式获得文件描述符，比如打开文件、目录、设备或创建管道或复制一个已经存在的文件描述符。简单起见，我们一般将文件描述符指向的对象称为“文件”；文件描述符消除了文件、管道和设备之间的差异，使它们看起来都像字节流。输入和输出指代为 I/O。

每个进程都有一张表（页表？）， xv6 内核以文件描述符作为这张表的索引，所以每个进程都有一个从零开始的文件描述符空间。按照惯例，进程从文件描述符 0（标准输入）读取数据，向文件描述 1（标准输出）写数据，向文件描述符 2（标准错误）写错误信息。接下来我们可以看到，shell 正是利用这个惯例来实现 I/O 重定向和管道。shell 保证任何时候总是有三个打开着的文件描述符[(user/sh.c:152)](https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L152)，它们是控制台默认的文件描述符。

系统调用 read 和 write 从文件描述符所指的文件中读或者写 n 个字节，`read(fd, buf, n)` 从文件描述符 fd 读取最多 n 字节的内容（fd 可能没有 n 字节的内容），然后复制到 buf 中并返回读取的字节数。每个指向文件的文件描述符都有一个偏移量与之关联。`read` 从当前文件的偏移量处开始读取数据，然后将偏移量加上读取的字节数。紧随其后的 `read` 将返回上一次读取返回的字节之后的字节。当没有字节可以读了的时候，`read` 返回 0 表示文件结束。

`write(fd, buf, n)` 从 buf 向 fd 写入 n 字节的内容并返回写入的字节数。只有当发生错误时才会写入少于 n 个字节的内容。与 `read` 相同，`write` 从当前文件描述符开始写入数据，然后将偏移量加上写入的字节数：每次 `write` 都是从上一次中断的地方开始的。

下面的程序（`cat`程序的本质）将数据从标准输入复制到标准输出。如果发生错误，他会像标准错误中写入错误信息。
```c
#include <unistd.h>   // For read(), write()
#include <stdio.h>    // For fprintf()
#include <stdlib.h>   // For exit()

int main() {
    char buf[512];
    int n;

    for (;;) {
        n = read(0, buf, sizeof buf);
        if (n == 0) // EOF
            break;
        if (n < 0) {
            fprintf(stderr, "read error\n");
            exit(1);
        }
        if (write(1, buf, n) != n) {
            fprintf(stderr, "write error\n");
            exit(1);
        }
    }
    return 0;
}
```
需要注意的是在这个代码片段中，`cat` 不知道它读的是文件、控制台还是管道。类似的，`cat` 也不知道它是向文件、控制台或者别的什么地方打印内容，文件描述符的使用和一些惯例（如0是标准输入，1是标准输出）使得我们可以轻松实现 cat。

系统调用 `close` 用来释放系统描述符，释放是为了系统调用 `open`、`pipe` 或 `dup` 能够重用该系统描述符。新分配的文件描述符总是当前进程中最小的未被使用的文件描述符。

文件描述符和 `fork` 的相互作用可以使 I/O 重定向更易于实现。`fork` 在复制父进程的内存时也会复制文件描述符表，因此子进程在开始时和父进程有相同的打开的文件。`exec` 会替换调用程序的内存但会保留调用程序的文件描述符表。这种方式可以让 shell 按照下面的过程实现 I/O 重定向：`fork` 一个进程，在子进程中，重新打开指定文件的文件描述符，然后调用 `exec`  执行新程序。下面是 shell 运行命令 `cat < input.txt` 的一个简易的代码实现，
```c
char *argv[2];

argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
```
子进程关闭文件描述符 0 后，然后使用 `open` 打开 `input.txt`，这样就能保证文件描述符 0 指向 `input.txt`，因为此时 0 是最新的可使用的文件描述符。之后 `cat` 就会在标准输入指向 `input.txt` 的情况下执行。父进程的文件描述符不会被上面的代码所影响，它只修改子进程的文件描述符。

xv6 shell 中的 I/O 重定向代码正是以上面的方式工作的[(user/sh.c:83)](https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L83)。当进程到达该处时，shell 已经 fork 了子 shell 并且 `rumcmd` 将调用 `exec` 执行新程序。

`open` 的第二个参数由一系列的标志组成，每个标志表示 1 位数据，这些标志控制 `open` 的操作。所有可能的取值定义在文件控制（fcntl）头中[(kernel/fcntl.h:1-5)](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/fcntl.h#L1-L5)：
|flags|meaning|
|---|---|
|O_RONLY|读|
|O_WONLY|写|
|O_RDWR|读写|
|O_CREATE|文件不存在则创建文件|
|O_TRUNC|将文件长度截为 0| 

`fork` 和 `exec` 为什么分成两个调用现在应该很清楚了：在这两个调用之间，shell 可以在不更改主 shell I/O 的前提下对子 shell 的 I/O 进行重定向。你可以想象一下，如果将这两个调用和为 `forkexec` 调用会发生什么事情。这样做之后 I/O 重定向将会显得十分笨拙，下面是几种可能的 I/O 重定向方案：shell 在调用 `forkexec` 之前修改 I/O 设置（执行完之后恢复修改）；或者 `forkexec` 也可将 I/O 重定向的指令作为参数；或者（最没吸引力的）每个程序比如 `cat` 自己完成 I/O 重定向。

尽管 `fork` 复制了文件描述符表，但是子进程和父进程之间会共享文件描述符对应的偏移量。考虑下面的例子：
```c
if(fork() == 0) {
    write(1, "hello ", 6);
    exit(0);
} else {
    wait(0);
    write(1, "world\n", 6);
}
```
代码执行后，文件描述符 1 指向的文件将会写入数据 `hello world`。父进程的 `write` 将在子进程的 `write` 后开始写（这得感谢 `wait`，让父进程只有等待子进程退出后才能写）。这种行为有利于顺序执行的 shell 命令有序输出，例如 `(echo hello; echo world)>output.txt`。

系统调用 `dup` 可以复制一个已有的文件描述符，返回一个指向同一个 I/O 对象的新描述符。两个文件描述符之间共享偏移量，就像被 `fork` 复制的文件描述符一样。下面是向文件中写入 `hello world` 的另一种方法：
```c
fd = dup(1);
write(1, "hello", 6);
write(fd, "world\n", 6);
```

两个由 `fork` 或 `dup` 导出的文件描述符共享一个偏移量。除此之外，文件描述符不会共享偏移量，即使用 `open` 打开相同的文件。`dup` 可以让 shell 实现下面的命令：`ls existing-file non-existing-file > tmp1 2>&1`。`2>&1` 告诉 shell 给这条命令一个复制了文件描述符 1 的文件描述符 2（将标准错误重定向到标准输出）。这样存在的文件的文件名和不存在的文件的错误信息都会写入 `tmp1` 中。xv6 shell 不支持错误文件描述符的 I/O 重定向但你现在直到如何实现它了。

文件描述符是一个强大的抽象，因为它隐藏了相关的细节：一个进程向文件描述符写入内容，可能是向一个文件，也可能是向一个设备比如控制台，也可能是一个管道。

### 1.3 管道

管道是一个小的内核缓冲区，它以文件描述符对（一个用于读，一个用于写）的形式提供给进程。从管道一端写入的数据可以从管道的另一端读到。管道为进程之间的通信提供了方法。

下面的代码运行 `wc` 程序并将管道的读端口作为标准输入：
```c
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

// pipe和fork系统调用、文件描述符操作都需要这些头文件

int main() {
    int p[2];
    char *argv[2];

    argv[0] = "wc";
    argv[1] = 0;

    if (pipe(p) < 0) {
        perror("pipe failed");
        exit(1);
    }

    if (fork() == 0) {
        close(0);        // 关闭标准输入文件描述符
        dup(p[0]);       // 复制管道读取端到文件描述符0
        close(p[0]);     // 关闭管道读取端
        close(p[1]);     // 关闭管道写入端

        execvp("/bin/wc", argv);  // 执行wc程序
        perror("exec failed");  // 如果exec失败，打印错误 信息
        exit(1);
    } else {
        close(p[0]);     // 关闭管道读取端
        // 向管道写入数据
        write(p[1], "hello world\n", 12);         close(p[1]);     // 关闭管道写入端
    }

    return 0;
}

```
程序调用 `pipe` 创建一个新的管道并将读和写的文件描述符记录在数组 `p` 中。`fork` 之后，父进程和子进程都有指向管道的文件描述符。子进程使用 `close` 和 `dup` 使文件描述符 0 指向管道的读端口、关闭 `p` 中的文件描述符，然后调用 `exec` 执行 `wc`。当 `wc` 从它的标准输入读取内容时，它实际上是从管道中读取内容。父进程关闭了管道的读端口，向写端口写入内容，然后关闭写端口。

如果没有数据准备好，那么管道中的 `read` 会一直等下去，除非写入了数据或者所有指向管道写端口的文件描述符都被关闭了；在后一种情况中，`read` 将会返回 0，就像是一份文件读到了最后。读操作会一直阻塞直到不可能再有新数据到来了，这就是为什么我们在执行 `wc` 之前要关闭子进程的写端口：如果 `wc` 中有文件描述符指向管道的写端口，那么 `wc` 就永远看不到 EOF 了。

xv6 对管道的实现（比如 `grep fork sh.c | wc -l`）和上面的描述是类似的[(user/sh.c:101)](https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L101)。子进程创建一个管道连接管道的左端和右端。然后分别为左端和右端调用 `fork` 和 `rumcmd` 并等待两者执行完毕。管道的右端也可能是一个包含了管道的命令（e.g., `a|b|c`），它需要 `fork` 两个新的子进程（一个 b 的一个 c 的）。因此，这个 shell 将会创建一个进程树。该树的叶子节点是命令，中间节点的进程，它们会等待左孩子和右孩子执行结束。

pipe 可能看起来和临时文件没上面区别： 
```
管道命令：echo hello world | wc
临时文件：echo hello world >/tmp/xyz; wc </tmp/xyz
```
在上面的这种情况中，管道至少有三个优点：
- 首先，管道会自动清除；使用文件重定位时，我们需要在任务完成后删除 `/tmp/xyz` 文件；
- 第二，管道可以传输任意长度的数据流，而文件重定位要求硬盘中有足够的空闲空间来存储所需的数据；
- 第三，管道可以并行的执行管道的步骤，而临时文件的方法要求第一个进程完成才能执行第二个；

### 1.4 文件系统

xv6 文件系统提供文件（它包含未解释的字节数组）和目录（它包含指向文件和其它目录的引用）。目录是一棵树，根节点是一个特殊的目录——`root`。路径 `/a/b/c` 表示在根目录 `/` 下的 `a` 目录中的 `b` 目录下有一个名为 `c` 的文件或目录。不从 `/` 开始的目录表示的是相对调用进程当前目录的目录，调用进程的当前目录可以通过系统调用 `chdir` 改变。下面的这些代码用来打开同一个文件（假设所有相关的目录都存在）：
```c
chdir("/a");
chdir("b");
open("c", O_RDONLY);

open("/a/b/c", O_RDONLY);
```
第一段代码将进程的当前目录更改为 `/a/b`；第二段代码没有改变当前进程的目录。

有的系统调用可以创建新的文件和目录：`mkdir` 用来创建新的目录，带有 `O_CREATE` 标志的 `open` 可以创建新的文件，`mknod` 用来创建设备文件。下面这三种方法是一些例子：
```c
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```
`mknod` 可以创建指向设备的特殊的文件，与设备文件关联的是主设备号和辅设备号（`mknod` 的后两个参数），这两个设备号唯一确定一个内核设备。创建了设备文件后，当进程打开这个文件进行操作时，内核将 `read` 和 `write` 的系统调用转发到内核设备上，而不是传递给文件系统。

文件名和文件本身不同；相同的底层文件叫作 inode，它可以有多个文件名，这些文件名叫作链接。每个链接由目录中的一个条目（an entry）组成；一个条目（entry）包括文件名和一个 inode 的引用。一个 inode 拥有一个文件的元数据（metadata），元数据中包括它的类型（文件、目录或设备）、长度、文件的内容在硬盘中的位置和连接到这个文件的链接数。

系统调用 `fstat` 可以从文件描述符指向的 inode 中检索信息，填充到 `struct stat` 中，`struct stat` 在 `stat.h` [(kernel/stat.h)](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/stat.h) 中进行了定义。
```c
#define T_DIR     1   // Directory
#define T_FILE    2   // File
#define T_DEVICE  3   // Device

struct stat {
  int dev;     // File system's disk device
  uint ino;    // Inode number
  short type;  // Type of file
  short nlink; // Number of links to file
  uint64 size; // Size of file in bytes
};
```
系统调用 `link` 用于创建另一个文件系统名称，该文件名称指向与现有文件相同的 inode。下面的代码创建了一个既叫作 a 又叫作 b 的文件。
```c
open("a", O_CREATE|O_WRONLY);
link("a", "b");
```
向 a 读写和向 b 读写是相同的。每个 inode 通过唯一的 inode number 进行识别。上面的代码执行后，a 和 b 指向相同的内容可以通过检查 `fstat` 进行确定：它们会返回相同的 inode number(`ino`) 并且 `nlink` 的值为 2。

系统调用 `unlink` 用于从文件系统中移除一个名字。文件的 inode 和硬盘空间拥有的文件内容只有当文件的链接数为 0 并且没有文件描述符指向它时才会释放。因此在上面的代码的最后添加
```c
unlink("a");
```
后，仍可使用 b 访问文件的内容和 inode。此外，
```c
fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");
```
是创建没有名称的临时 inode 的常用方法，当程序关闭 `fd` 或者退出时，该 inode 将会被清除。

Unix 在 shell 中为用户级的程序提供可调用的文件实体程序，例如 `mkdir`、`ln` 和 `rm`。这个设计允许任何人通过添加新的用户级程序来扩展命令行接口。现在看来，这种设计是很显然的，但在 Unix 时代的其他系统经常将这样的命令构建到 shell 中（并将 shell 构建到内核中）

有一个例外，那就是 `cd`，它构建在 shell 中[(user/sh.c:161)](https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L161)。`cd` 需要改变 shell 本身的工作目录。如果 `cd` 作为一条常规的命令运行，shell 将会 fork 一个子进程，然后在子进程中运行 `cd`，这样做只能改变子进程的工作目录，而无法改变父进程的工作目录。

### 1.5 真实的世界

Unix 将“标准”的文件描述符，管道，和便于操作它们的 shell 命令整合在一起，这是编写通用、可重用程序的重大进步。这个想法激发了 Unix 强大和流行的“软件工具”文化，而且 shell 也是首个所谓的“脚本语言”。Unix 的系统调用接口在今天仍然存在于许多操作系统中，诸如 BSD，Linux，以及 Mac OS X。

Unix 的系统调用接口使用了可移植操作系统标准（the Portable Operating System Interface，POSIX）进行标准化。xv6 不符合 POSIX 标准：它缺少许多系统调用（比如 `lseek`），还有提供了许多不同于 POSIX 标准的系统调用。我们的主要目标是在简单清晰的基础上提供一个简单的类 Unix 系统调用的接口。有些人为 xv6 扩展了一些系统调用并扩展了简单的 C 库来运行基础的 Unix 程序。与 xv6 相比，现代内核提供了更多的系统调用和更多种类的内核服务。例如，它们支持互联、窗口系统、用户级线程、许多设备的驱动等等。现代内核不断快速的发展提供了许多超过 POSIX 的特性。

Unix 使用一组文件名和文件描述符接口统一地访问多种类型的资源（文件、目录和设备）。这个想法可以被扩展为更多种类的资源；比如 [Plan 9]()，它将“资源即是文件”的概念应用到了互联网、图像中等等。但是，大多数由 Unix 导出的操作系统没有遵循这一规则。
> Plan 9: Dave Presotto, Rob Pike, Ken Thompson, and Howard Trickey. Plan 9, a distributed system. In In Proceedings of the Spring 1991 EurOpen Conference, pages 43–50, 1991.

文件系统和文件描述符是一个强大的抽象。即使如此也存在着其它的操作系统接口模型。Multics，Unix 的前辈，将文件抽象为一种类似内存的概念，产生了十分不同的系统接口。Multics 的设计的复杂性对 Unix 的设计者们产生了直接的影响，他们因此想把文件系统的设计做的更简单。

xv6 没有提供用户或保护一个用户不受另一个用户影响的概念；用 Unix 的话说，就是所有的 xv6 进程都以 root 身份运行。

本书考察 xv6 是如何实现类似 Unix 的接口的，但涉及的想法和概念可以运用到 Unix 之外很多地方上。任何一个操作系统都需要让多个进程复用硬件，实现进程之间的相互隔离，并提供进程间通讯的机制。在学习 xv6 之后，你应该了解一些其他的更加复杂的操作系统，看一下他们当中蕴含的 xv6 的概念。