## 5.1 CPU概述

### 5.1.1 指令执行过程

CPU的基本功能周而复始的取指令和执行指令，CPU中一条指令的执行可以大致的分为以下五个过程：

- 取指令并计算下一条指令地址
- 对指令操作码进行译码
- 计算源操作数地址并取源操作数
- 数据操作
- 计算目的操作数地址并将结果存到目的操作数中

由此可以分析出指令的四个基本操作：读取某个存储单元的内容（可能是指令或操作数或操作数地址）并将其装入某个寄存器中；把一个数据从某个寄存器存入给定的存储的单元中；把一个数据从某个寄存器送到另一个寄存器或ALU的输入端；进行某种算术运算或逻辑运算，将结果送入某个寄存器；

寄存器传送语言（Register Transfer Language, RTL)：$R[r]、M[addr]、\rightarrow$

### 5.1.2 CPU的基本功能和基本组成

除了基本的取指令、执行指令外，CPU还要能够发现和处理“异常”情况和“中断”请求

CPU可以看作由数据通路和控制部件两大部分组成

- 数据通路：指令执行过程中数据所经过的路径，包括路径上的部件称为数据通路（ALU、通用寄存器、状态寄存器、cache、MMU、浮点运算逻辑、异常和中断处理逻辑等）
- 控制部件：根据每条指令功能的不同生成对数据通路的控制信号

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231010150019493.png" alt="image-20231010150019493" style="zoom: 50%;" />

### 5.1.3 数据通路的基本结构

组合逻辑单元（操作单元，MUX、Adder、ALU、Decoder等）和存储元件（状态元件）通过总线或分散的方式连接在一起形成数据通路

- **单总线数据通路**：将ALU及所有寄存器通过一条内部的公共总线连接起来，构成单总线数据通路。因为此总线在CPU内部，所以称为**CPU内部总线**，不要将它与连接CPU、存储器和I/O设备的**外部系统总线**相混淆。以下对单总线数据通路的四种基本操作进行描述：

  <img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231010151310363.png" alt="image-20231010151310363" style="zoom:50%;" />

  - **在通用寄存器之间传送数据**：例如$R[R0]\rightarrow R[Y]$，对应的控制信号为 "$R0_{out}, Y_{in}$"
  - **完成算术、逻辑运算**：例如$R[R1]+R[R2]\rightarrow R[R3]$，由于总线是一组共享的传输信号线，不能存储信息，某一个时钟周期内只能有一个部件把信息送到总线上，所以执行该指令需要三个时钟周期
    - 第一个时钟周期，$R[R1]\rightarrow R[Y]$，控制信号为 "$R1_{out}, Y_{in}$"
    - 第二个时钟周期，$R[R2]\rightarrow 总线$，控制信号为 "$R2_{out}, add, (Z_{in})$"（当第二个数据送到总线之后，ALU不需要进行存储即可进行加法操作，ALU的输出一般是直接送Z，实际上无须$Z_{in}$）
    - 第三个时钟周期，$R[Z] \rightarrow R[R3]$，控制信号为 "$Z_{out}, R3_{in}$"
  - **从内存中读取一个字**（指令或数据或数据的地址）：例如$M[R[R1]]\rightarrow R[R2]$，
    - 第一个时钟周期：$R[R1]\rightarrow MAR$，控制信号为 "$R1_{out}, MAR_{in}$"
    - n个时钟周期：在第二个时钟周期到来后，经过一个锁存时间 $Clk-to-Q$，$MAR$中的地址被送到地址总线上，$CPU$ 发出 $read$ 命令的同时，通过 $WMFC$ 控制信号使 $CPU$ 转入等待状态（此时 $CPU$ 会不断的对 $MFC$ 信号进行采样，直到检测到 $MFC$ 信号有效，才退出，这通常需要多个时钟周期），控制信号为 "$read, WMFC$"
    - 最后一个时钟周期：检测到 $MFC$ 信号有效后，就直接将 $MDR$ 中的内容通过内部总线送到 $R2$，$MDR\rightarrow R[R2]$，控制信号为 "$MDR_{out}，R2_{in}$"
    - 注：早期的计算机，其CPU和主存之间采用“异步”方式进行通信，所以需要WMFC控制信号，当前的计算机，CPU和主存之间一般采用“同步”的方式进行通信，存储器总是在固定的几个时钟周期内准备好数据，因而CPU不必等待主存发回MFC信号，直接在固定的几个周期后进行读取即可，所以也不需要WMFC控制信号
  - **把一个字写入主存**：例如$R[R1]\rightarrow M[R[R2]]$
    - 第一个时钟周期：$R[R1]\rightarrow MDR$，控制信号 "$R1_{out}, MDR_{in}$"
    - 第二个时钟周期：$R[R2]\rightarrow MAR$，控制信号 "$R2_{out}, MAR_{in}$"
    - n个时钟周期：等待主存将 $MDR$ 中的内容写到 $MAR$ 的内容对应的存储单元中，控制信号 "$write, WMFC$"

- **三总线数据通路**：为了提高机器性能，执行一条指令所需的时钟周期应该尽可能的少，单总线数据通路中，一个时钟周期只允许传送一个数据，因而指令执行效率低，因此出现了三总线数据通路。

  - 三总线数据通路的所有通用寄存器都在一个双口寄存器堆中；减少了ALU中的Y寄存器和Z寄存器

  - 在三总线数据通路中执行一条三操作数指令只需一个时钟周期即可完成，例如 $R[R1]\,\,op\,\,R[R2]\rightarrow R[R3]$，控制信号为 "$R1_{out}, R2_{out}, op,R3_{in}$

    <img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231010155655032.png" alt="image-20231010155655032" style="zoom:50%;" />
    
    

## 5.2 单周期处理器设计

以MIPS系统中的5条R型指令、5条I型指令、1条J型指令为例，指令的内容和功能见书袁书P152

### 5.2.1 单周期处理器的数据通路的设计

  ![image-20231010170513753](C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231010170513753.png)

![image-20231010170608851](C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231010170608851.png)

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231010170641677.png" alt="image-20231010170641677" style="zoom:80%;" />

- $lw$ 指令：$M[R[Rs] + SignExt(imm16)]\rightarrow R[Rt]$
- $sw$ 指令：$R[Rt]\rightarrow M[R[Rs] + SignExt(imm16)]$
- 因为运算类指令和 $Load$ 指令写入目的寄存器的来源不同，所以在 $busW$ 端增加了一个多路选择器，由控制信号 $MemtoReg$  控制选择将 $ALU$ 的结果还是存储器读出的数据写入目的寄存器
- 因为 $Load/Store$ 指令需要读取数据存储器，所以增加了数据存储器。
- 访存地址由$ALU$计算得到所以$Adr$连到了$ALU$的输出端
- $sw$指令中，将$Rt$的内容送存储器，因此直接将$busB$连接到存储器的$DataIn$
- $MemWr$用作“写使能”
- $Load/Store$指令的地址运算对立即数$imm16$进行符号扩展，所以$ALUctr$输入端的操作类型是不判溢出的加法$addu$

![image-20231010201158662](C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231010201158662.png)

- $beq$ 指令：$if(R[Rs]=R[Rt])\,\,\,\,PC\leftarrow PC+4+(SignExt(imm16)*4) \,\,\,\,else\,\,\,\, PC\leftarrow PC+4$

- 增加了取指令部件，转移目标地址在下地址逻辑中实现。下地址逻辑的输入有：$PC$、$imm16$、$Zero$、$Branch$，在$ALU$中对$R[Rs]$和$R[Rt]$做减法得到一个$Zero$标志，根据$Zero$标志可判断是否转移，$Branch$ 信号表示当前指令是否为分支指令，决定是否按照分支指令的方式计算下一条指令的地址

- 支持分支指令功能的下地址逻辑设计（左）、支持分支+跳转指令的下地址逻辑设计

  ![image-20231010202706221](C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231010202706221.png)

  - 因为指令长度地址为32位，主存按字节编址，所以指令地址总是4的倍数，即最后两位总是00，因此PC中只需存放前30位地址，即PC< 31:2 >，下条地址的计算方法为
    - 顺序执行时：$PC<31:2> \leftarrow PC<31:2> + 1$
    - 转移执行时：$PC<31:2>\leftarrow PC<31:2>+1+SignExt[imm16]$
    - 跳转执行时：$PC<31:2>\leftarrow PC<31:28>||target<25:0>$
    - 取指令时：指令地址 = $PC<31:2>|| ''00''$

![image-20231010203411227](C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231010203411227.png)

## 5.3 硬布线控制器

一般用于RISC指令集系统



## 5.4 微程序控制器

一般用于CISC指令集系统





## 5.5 异常和中断处理

### 5.5.1 基本概念

**内部异常**

- 根据发生原因分类：硬故障中断、程序性异常(软中断)
  - **硬故障中断**：由硬连线路出现异常引起。如存储器校验错、总线错误等
  - **程序性异常**：由CPU执行某个指令而引起的发生在处理器内部的异常事件。如整除0、溢出、断点、单步跟踪、访问超时、非法操作码、栈溢出、缺页、地址越界等
- 按异常发生的报告方式和返回方式不同分为：故障、自陷和终止
  - **故障(fault)**：它是在引起故障的指令启动后、执行结束前被检测到的一类异常事件。
    - 例如，指令译码时出现”非法操作码”，取指令或数据时，发生“段不存在”、“缺页”或“保护错”，执行整数除法指令时，发现“除数为0”
    - 对于“段不存在”、“缺页”，经过异常处理后，将需要的段或页从磁盘中调入了主存后，可回到发生故障的指令继续执行，因此，断点为当前发生故障的指令
    - 对于“非法操作码”、“保护错”、“除数为0”，无法通过异常处理解决故障，因此不能回到原断点处，必须终止进程的执行
  - **自陷(trap)**：预先安排的一种“异常”事件。当自陷指令是返回指令时，并不能返回到下一条指令执行，而是返回到转移目标指令执行。80x86中用于程序调试的“断点设置”就是通过“自陷”功能实现的。系统调用指令、条件自陷指令都属于陷阱指令
  - **终止(abort)**：在执行指令过程中发生了使及其无法继续执行的硬件故障。如控制器出错、存储器校验错等，程序无法继续执行，只能调出中断程序来重启系统。这种异常于故障和自陷不同，不是由特定指令产生，而是随机产生的

**外部中断**

每条指令执行完之后，CPU都会主动的去查询有没有中断请求，有的话，则将下一条指令地址作为断点保存，然后转中断处理程序，结束后继续回到断点执行。中断可分为可屏蔽中断和不可屏蔽中断：

- 可屏蔽中断：是指通过可屏蔽中断请求线INTR向CPU发出的中断请求。CPU可以在中断控制器中设置相应的屏蔽字来决定是否屏蔽该中断
- 不可屏蔽中断：是指通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，通常是非常紧急的硬件故障，比如电源掉电等。这类中断信号不可屏蔽，以让CPU快速处理这类紧急事件



### 5.5.2 异常和中断的响应过程

- **关中断**：IF为1，开中断；IF为0，关中断；（对于外部I/O中断，都属于可屏蔽中断，只有当IF=1，开中断时，外部I/O中断才会被响应；如果没有具体说明什么中断，则需要考虑中断为不可屏蔽中断的情况，无论IF为何值，CPU都需要立即对来自NMI(NonMaskable Interrupt)引脚的不可屏蔽中断进行响应）
- **保存断点和程序状态**
- **识别异常和中断并转到相应的处理程序**
  - 异常识别：软件识别方式
  - 中断识别：软件或硬件识别方式(向量中断)
