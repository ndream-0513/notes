## 2.1 I/O接口

I/O接口(I/O模块)是用来解决计算机主机部件和外设之间相互连接问题的，比如工作速度不匹配、数据格式不同等。各种I/O控制器或设备控制器、适配卡、适配器等都是I/O接口，在大型机中，I/O模块就是担负大量复杂的外设控制任务的通道或I/O处理器

### 2.1.1 I/O接口的功能

I/O接口是用来连接主机和外设的，因此，它在外设侧和主机侧各有一个接口，外设侧的接口称为外部接口、主机侧的接口称为内部接口。I/O接口一般具有以下功能：数据缓冲；错误或状态检测；控制和定时；数据格式转换

### 2.1.2 I/O端口及其编址

I/O端口实际上就是I/O接口中的寄存器，例如数据缓冲寄存器就是数据端口，控制/状态寄存器就是控制/状态端口。为了便于CPU对I/O设备的快速选择和对I/O端口的寻址，所以必须对所有I/O接口中的寄存器进行编址，有独立编址和统一编址两种方式

- 独立编址：拥有自己的地址空间。
  - 优点：I/O端口数量少，只需少量地址线，因此I/O端口译码简单，寻址速度快；
  - 缺点：I/O地址空间与主存地址空间相互独立，无法用主存的访存指令对I/O地址空间的寄存器进行访存（因为有可能会出现相同的地址码），故需用专门的I/O指令来表明访问I/O地址空间；I/O指令一般只提供简单的操作，故程序设计的灵活性差
- 统一编址(存储器映射方式)：I/O地址空间和主存地址空间统一编址。
  - 优点：任何对内存的存取指令都可以用来访问主存空间的I/O端口，并且所有和主存有关的寻址方式都可以用于I/O寻址，因此程序设计具有非常大的灵活性
  - 缺点：译码电路复杂，译码时间长，外设的寻址时间长



## 2.2 I/O数据传送控制方式

主要有三种不同的方式：程序直接控制、中断控制和DMA控制

### 2.2.1 程序直接控制I/O方式

- 无条件传送方式(同步传送方式)：当CPU采用无条件传送方式对外设进行I/O操作时，CPU会对外设接口进行周期性的定时访问，直接对I/O端口进行数据存取。在这种方式下，处理器在I/O操作上的时间开销多少于定时访问的时间间隔有关，对于慢速设备，时间间隔很长，所以I/O操作不会占用CPU太多的时间；而对于快速设备，时间间隔很短，会占用很多CPU时间

- 条件传送方式(异步传送方式)：这是一种通过查询I/O接口中的状态来控制数据传送的方式，所以也被称为程序查询方式。根据查询启动方式的不同，程序查询方式可分为定时查询和独占查询，
  - 定时查询：周期性地查询接口状态，每次查询总是一直等到条件满足，才进行一个数据的传送，传送完成后返回到用户程序
  
  - 独占查询：一旦设备启动，CPU就一直对设备进行查询，此时CPU和外设完全串行工作。以下是打印机使用独占查询的例子： 
  
    ```c
    copy_string_to_kerne(strbuf, kernelbuf, n);		// 将字符串复制到内核缓冲区
    for (i = 0; i < n; i ++) {						// 对于每个打印字符循环执行
    	while (printer_status != READY);			// 等待直到打印机状态为“就绪”
    	*printer_data_port = kernelbuf[i];			// 向数据端口发送一个字符
    	*printer_control_port = START;				// 发送“启动打印”命令
    }
    return ();										// 返回
    ```
  
  - 设备能否采用条件转移方式，主要取决于I/O设备本身的特点以及设备是否能够独立启动I/O等
  
    - 键盘和鼠标、磁盘、磁带和光盘这类的成块传送设备都不适合使用条件转移方式。键盘和鼠标虽然可以独立启动I/O，但是由于设备的启动是用户随机的，有可能会因为用户长时间没有输入，而导致查询时间长；成块传送设备，每个数据的传送时间都很短，如果使用定时查询，每次查询传送一个数据，则会因为频繁查询而使处理器为I/O操作花费较多时间
    - 针式打印机等字符类设备适用于条件查询方式。因为每个字符间的传输时间较长，并且每传送一个字符需要启动一次

### 2.2.2 程序中断I/O方式

- **中断I/O的基本思想：**

  - 当前进程P1需要进行一个I/O操作时，它会先启动外设进行第一个数据的I/O操作，并挂起执行I/O操作的进程P1使其被阻塞
  - 然后从就绪队列中选择另一个进程P2执行，此时，外设和CPU并行工作
  - 当外设完成I/O操作时，便向CPU发出中断请求
  - CPU响应中断请求后，终止正在执行的P2，转入“中断服务程序”，在“中断服务程序”中再启动数据的I/O传送任务
  - “中断服务程序”执行完之后，返回原来被终止的进程P2的断点处继续执行（P1进入就绪队列）

- 以下是打印机使用中断I/O的例子：

  ```c
  /* "字符打印"系统调用服务例程 */
  copy_string_to_kernel(strbuf, kernelbuf, n);	// 将字符串复制到内核缓冲区
  enable_interrupts();							// 开中断，允许外设发出中断请求
  while (printer_status != READY);				// 等待直到打印机状态为“就绪”
  *printer_data_port = kernbuf[i];				// 向数据端口输出第一个字符
  *printer_control_port = START;					// 发送“启动打印”命令
  scheduler();									// 阻塞用户进程P1，调度进程P2
  ```

  ```
  /* "字符打印“中断服务程序" */
  if (n == 0) {									// 若字符串打印完，则
  	unblock_user();								// 进程P1解除阻塞并进入就绪队列
  } else {
  	*printer_data_port = kernelbuf[i];			// 向数据端口输出一个字符
  	*printer_control_port = START;				// 发送“启动打印”命令
  	n = n - 1;									// 未打印字符数减1
  	i = i + 1;									// 下一个打印字符指针加1
  }
  acknowledge_interrupt();						// 中断回答（清除中断请求）
  return_from_interrupt();						// 中断返回 
  ```

  （当P1要打印一个字符串时，将字符串复制到缓冲区，开中断，等待打印机就绪，向打印机接口发送第一个字符，启动打印，阻塞P1，调用P2，第一个字符打印完，打印机发送中断请求，CPU响应中断请求，终止P2，转入“中断服务程序”，判断字符串是否打印完，打印完，解除P1的阻塞并放入就绪队列，清除中断请求，中断返回；未打印完，向打印机发送第二个字符，启动打印，n=n-1，i=i+1，清除中断请求，中断返回）

- **中断系统的基本职能和结构**

  - **及时记录各种中断请求信号**。通常用一个中断请求寄存器来保存
  - **自动响应中断请求**。CPU在每条指令执行完、下条指令取出前，会自动检测中断请求引脚，发现有中断请求时，则根据情况决定是否响应和响应哪个中断请求
  - **自动判优**；**保护被中断程序的断点和现场**
  - **中断屏蔽**：通过中断屏蔽实现多重中断的嵌套，中断屏蔽功能通过一个中断屏蔽字寄存器来实现

  <img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231014093251818.png" alt="image-20231014093251818" style="zoom:50%;" />

  - 来自各个设备的中断请求记录在**中断请求寄存器**中的对应位
  - 每个中断源有各自的中断屏蔽字，在进行相应的中断处理时它被送到**中断屏蔽字寄存器**中（中断屏蔽字是用来实现中断嵌套的，所以中断屏蔽字应该来自正在执行的中断的中断源）
  - CPU运行程序时，在当前指令执行完、取出下一条指令之前，会通过采样**中断请求信号**引脚(intel为INTR引脚)来自动查看是否有中断，若有则会发出相应的中断回答信号，中断回答信号启动**“中断查询”**线，将所有未被屏蔽的中断请求信号送到**中断判优电路**中，判优电路根据中断响应优先级选择一个优先级最高的中断源，然后用一个**编码器**对该中断源进行编码，得到对应的中断设备类型号
  - CPU取得中断源的标识信息后，经过一系列的转换，就可得到对应的中断程序的首地址，在下一个指令周期开始，CPU执行响应的中断服务程序

- **中断过程**：中断过程包括两个阶段：中断响应、中断处理。中断响应阶段由硬件实现，中断处理阶段则由CPU执行中断服务程序完成，所以中断处理过程是由软件实现的

  - **中断响应**：是指主机发现中断请求、终止现行程序的执行、到调出中断程序这一过程。因此，需要完成以下三个任务：
    - **保护好被中断的程序的断点处的关键信息**：将**程序现场**(用户可见的工作寄存器的内容，可以用指令直接读取)使用指令保存到栈中，由软件实现；将**断点信息**(PC、PSWR中的内容，无法用指令直接读取)保存到一个特定的地方(栈或专门的寄存器)，由硬件实现
    - **识别中断源并根据中断响应优先级进行判优**
    - **调出中断服务程序**：将中断服务程序的首地址和初始程序状态字分别送PC和PSWR(Program Status Word Register)
  - 在保护断点或程序现场时，如果又有其它中断被响应，则原被保存的现场就会被破坏，因此，通常用一个“中断允许”寄存器来实现控制，当“中断允许”(开中断)时，才能进行中断响应。综上，**中断响应应该具备**以下**三个条件**：CPU处于“开中断”状态；至少有一个未被屏蔽的中断请求；当前指令刚执行完；
  - 中断响应通过一条中断隐指令(硬件实现)来完成：关中断；保护断点；识别中断源并转中断服务程序；
  - **中断源的识别和判优**可分为**软件查询**和**硬件判优**两大类：
    - **软件查询方式**：当CPU检测到中断请求时，通过响应中断信号，自动转到一个特定的中断查询程序中，在中断查询程序中，按中断优先顺序一次查询哪个设备有中断请求，并转到第一个查询到有中断请求的中断服务程序中
    - **硬件判优方式(向量中断方式)**：过程如图8.23第三条内容所示。在向量中断方式下，通常把中断服务程序的PC和PSWR称为中断向量(Interrupt Vector, IV)，所有的中断向量存储在一个中断向量表中，中断向量的地址称为向量地址(Vector Address, VA)
  - 现代计算机多采用**独立请求**的方式来进行中断源的识别和判优
  - 中断处理：通过中断服务程序完成，不同的中断源的中断服务程序不同

- 中断适合的设备：对于鼠标、键盘、打印机等外设都适合使用中断I/O方式，传输数据少、中断频率低、可以得到及时的响应；但是对于硬盘这种高速外设，数据传输快、数据多、中断频率高，会导致CPU被频繁的打断，而且由于需要保护现场和断点等操作，二外开销大，所以适合采用中断I/O方式，一般采用DMA方式

### 2.2.3 DMA方式

DMA(Direct Memory Access，直接存储器存取)，该输入方式通过专门的DMA接口硬件来控制外设与主存之间的直接数据交换，**数据不通过CPU**。DMA方式与中断I/O方式一样，也是采用“请求-响应”方式，只是中断I/O方式请求的是处理器时间，而**DMA方式**下**请求**的是**总线控制权**。DMA方式主要用于磁盘等高速设备的数据传送，以下是使用DMA进行磁盘数据读取的一个例子：

![image-20231014111228061](C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231014111228061.png)

- **三种DMA方式**：由于DMA和CPU共享主存，为使两者协调调用主存，DMA通常采用以下三种方式之一进行数据传送：

  - CPU停止方式：DMA传输时，CPU停止使用主存
  - 周期挪用方式：也称周期窃取方式。当I/O设备有DMA请求时，如果主存不在访存，此时I/O的访存与CPU未发生冲突，I/O设备可以直接和主存交换数据；如果主存在访存，需等待主存存取周期结束后，才能进行访存；如果I/O和CPU同时请求访存，此时I/O设备先访存。这种DMA方式是一种单字传送方式
  - 交替分时访问方式：将一个存储周期分为两个时间片，一个给CPU、一个给DMA

- **DMA操作步骤**：

  - DMA控制器的预置（初始化）
    - 准备内存区。若是外设输入数据，则进行内存缓冲区的申请，并对缓冲区初始化；若是输出数据到外设，则先在内存准备好数据
    - 设置传送参数。执行输入输出指令来测试外设状态，并对DMA控制器设置各种参数
    - 发送“启动DMA传送”命令，然后调度CPU执行其他进程
  - DMA数据传送（DMA传送）
  - DMA结束处理（后处理）
    - 当字计数器为0，则发出“DMA结束”中断信号给CPU，转入中断服务程序，做一些数据校验等后处理工作

  ```c
  /* “字符打印”系统调用处理例程 */
  copy_string_to_kernel(strbuf, kernelbuf, n);	// 将字符串复制到内核缓冲区
  initialize_DMA();								// 初始化DMA控制器（准备传送参数）
  *DMA_control_port = START;						// 发送“启动DMA传送”命令
  scheduler();									// 阻塞用户进程P，调度其他进程执行
  ```

  ```c
  /* “DMA结束”中断服务程序 */
  acknowledge_interrupt();						// 中断回答（清除中断请求）
  unblock_user();									// 用户进程P解出阻塞，进入就绪队列
  return_from_interrupt();						// 中断返回
  ```

- **DMA与存储系统**

  - 在虚拟存储系统中，页面数据同时有物理地址和虚拟地址，那么DMA是以虚拟地址还是以物理地址工作呢？
  - 如何解决I/O数据一致性问题

  

  



