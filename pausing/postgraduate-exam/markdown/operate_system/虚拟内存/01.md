## 01 地址转换

### 1.1 假设条件

用户的地址空间连续地存放在物理内存中；地址空间小于物理空间的大小；每个地址空间的大小完全相同；

对`x = x + 3;`反编译得到的x86汇编进行分析，可以得到发生了几次内存访问：

```
128: movl 0x0(%ebx), %eax	// 假定x的地址已经存入ebx中，通过movl指令将ebx中的值加载到eax中
132: addl $0x03, %eax		// eax中的值加3存入eax中
135: movl %eax, 0x0(%ebx)	// 将eax中的值存到ebx中

// eax accumulator 累加寄存器
// ebx base 基地址寄存器
```

由上图可得，程序的地址空间是从0开始到16KB结束，它包含的所有内存引用都应该在这个范围内；但是对于虚拟内存来说，进程在物理内存中的位置不一定从地址0开始，由此引出了下面两个问题：如何在内存中重定位一个进程，同时对该进程透明？如何提供一种虚拟地址空间从0开始的假象？

### 1.2 动态(基于硬件)重定位

动态重定位，通过两个硬件寄存器(**基址寄存器**和**界限寄存器**)让我们能够将程序的地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间；进程中使用的内存引用都是虚拟地址，物理地址由虚拟地址加上基址寄存器中的内容得到；以下是一条基于动态重定位的指令的执行过程`128: movl 0x0(%ebx), %eax`：

- PC中的值被设置为128；当硬件需要获取这条指令时，使用128加上基址寄存器中的内容(32KB)，得到物理地址，从物理地址中读取指令，之后开始执行这条指令；
- 进程加载x的虚拟地址(15KB)，处理器将虚拟地址加上基址寄存器中的内容(32KB)，得到x的物理地址47KB，从而获得需要的数据；

在上面的例子中界限寄存器被置为16KB，当进程访问超过这个界限或者为负数的虚拟地址时，CPU将触发异常，进程最终可能被终止；

> 每个CPU中都有一对基址加界限的寄存器，有时我们将CPU中的负责地址转换的部分统称为内存管理单元(MMU)

### 1.3 硬件支持：总结

| 硬件要求                         | 解释                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| 特权模式                         | 需要，以防用户模式的进程执行特权操作，一般用一位的psw进行区分 |
| 基址/界限寄存器                  | 每个CPU需要一对寄存器来支持地址转换和界限检查                |
| 能够转换虚拟地址并检查它是否越界 | 使用电路来完成转换和检查界限                                 |
| 修改基址/界限寄存器的特权指令    | 在让用户程序运行之前，操作系统必须能够设置这些值             |
| 能够触发异常                     | 如果进程试图使用特权指令或内存越界，则需触发异常程序         |
| 注册异常处理程序的特权指令       | 操作系统必须能告诉硬件，如果异常发生，那么执行哪些代码       |

### 1.4 操作系统的问题

| 操作系统的要求 | 解释                                                         |
| -------------- | ------------------------------------------------------------ |
| 内存管理       | 需要为新进程分配内存；<br />从终止的进程回收内存；<br />（一般通过空闲列表来管理内存） |
| 基址/界限管理  | 必须在上下文切换时正确设置基址/界限寄存器；                  |
| 异常管理       | 操作系统必须提供异常处理程序或调用一些函数；                 |

使用动态重定位时，栈和堆之间有一大块“空闲”空间，简单的通过基址寄存器和界限寄存器实现的虚拟内存很浪费，并且存储不灵活，因此推出了**分段：泛化的基址/界限**；



## 02 分段

### 2.1 分段：泛化的基址/界限

在MMU中引入多个基址和界限寄存器对，地址空间内的每个逻辑段一对。一个段是地址空间中一个连续定长的区域，在典型的地址空间中一般划分为代码、栈和堆三个不同的逻辑段；以下是分段的地址空间存储在物理内存中的一个例子：



> 地址转换实例：
>
> - 虚拟地址100(在代码段中)，物理地址 = 100 + 32KB = 32868，得到物理地址后会检查该地址是否在界限内(100＜2KB)，发现在，然后发起对物理地址32868的引用；
> - 虚拟地址4200(在堆中)，物理地址 = 4200 - 4KB(在地址空间中的偏移量) + 34KB = 34920；
> - 虚拟地址7KB，非法地址，段异常(segmentation violation)或段错误(segmentation fault)；

### 2.2 引用哪个段？

一般使用**显式方式**来决定引用哪个段，以下是典型地址空间使用显示方式分段的**例子**：假设虚拟地址空间为14bit，典型地址空间有三个逻辑段，使用虚拟地址的前2位来对段进行标识，后12位作为段内偏移，将偏移量与基址寄存器相加，硬件就得到了最终的物理地址。

> 引入偏移量，可以简化堆段边界的判断，只需检查偏移量是否小于界限即可，大于界限的为非法地址

也可使用**隐式方式**来决定引用哪个段，在隐式方式中，硬件通过地址产生的方式来确定段。例如当地址由程序计数器产生时，地址在代码段；如果基于栈或基于指针，那么它一定在栈段；其它地址则在堆段中；

### 2.3 栈怎么办？

栈在地址空间中是反向增长的，为了加以区分，在硬件中需要增加一个标识位来确定段的增长方向；以下是一个栈段的例子：



访问虚拟地址15KB，物理地址 = 28KB - (15KB - 14KB)

### 2.4 支持共享

增加几位保护位可以在不影响内存数据的前提下，提高内存的存储效率，何乐而不为呢？以下是段共享的一个例子：



### 2.5 操作系统支持

| 问题                               | 答案                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| 操作系统在上下文切换时应该做什么？ | 对各个段寄存器中的内容进行保存和恢复                         |
| 如何管理内存的空闲空间？外部碎片   | - 紧凑物理内存，重新安排原有的段<br />- 利用空闲列表算法，试图保留大的内存块用于分配 |



## 03 空闲空间管理



## 04 分页

使用空闲列表算法无法解决外部碎片的问题，解决外部碎片的唯一办法就是永远不要分配不同大小的内存块，即采用分页来实现虚拟内存。以下是用分页实现虚拟内存的一个例子：

将64B的地址空间等分为16B的页，128B的物理地址等分为相同大小的页帧，每一个页帧可以存储一个虚拟内存页；



> 使用页表来保存虚拟页面到页帧的地址转换，上图中的页表为(vp0→pf3)、(vp1→pf7)、(vp2→pf5)、(vp3→pf2)；每个进程都有一个页表

虚拟地址 = 虚拟页面号(virtual page number, VPN) + 页内偏移量(offset)；本例中，地址空间中有4个页，所以VPN占2位，offset占4位，