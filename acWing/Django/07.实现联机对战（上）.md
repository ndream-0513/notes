## 实现联机对战（上）

### 1、统一长度单位

我们在渲染地图的时候，要看一下长和宽，取一个最小值，将最终地图渲染成一个16：9的地图。修改playground的js文件，首先需要实现一个resize函数可以调整长宽比，当用户调整窗口大小时，地图大小可以随着用户调整窗口的大小而动态变换。我们需要将show中的```this.root.$ac_game.append(this.$playground);```放到构造函数中，不能每次show都append一个新元素，所以把这个放到构造函数中

```javascript
class AcGamePlayground {
    constructor(root) {
        this.root = root;
        this.$playground = $(`
        <div class="ac_game_playground"></div>
        `);
        
        // 修改了
        this.root.$ac_game.append(this.$playground);

        this.hide();

        this.start();
    }

    get_random_color() {
        let colors = ["blue", "red", "pink", "skyblue", "green"];
        return colors[Math.floor(Math.random() * 5)];
    }

    start() {
        // 修改了
        let outer = this;
        
    	$(window).resize(function() {
        	outer.resize();		// 改变窗口大小就resize一下    
        });
    }
    
    // 修改了
    resize() {
        console.log("resize");
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        let unit = Math.min(this.width / 16, this.height / 9);
        this.width = unit * 16;
        this.height = unit * 9;
        this.scale = this.height;
        
        if (this.game_map) this.game_map.resize();
    }

    show() {
        this.$playground.show();

        this.resize();
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        this.game_map = new GameMap(this);
        this.players = [];
        this.players.push(new Player(this, this.width/2, this.height/2, this.height*0.05, "white", this.height * 0.15, true));

        for (let i = 0; i < 5; i ++) {
            this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, this.get_random_color(), this.height * 0.15, false));
        }
    }

    hide() {
        this.$playground.hide();
    }
}
```

保存调试一下，看是否输出了resize。此时黑框的大小还没有改变，所以需要修改Gampmap下的js文件，创建一个resize函数，可以动态的修改黑框的长和宽

```javascript
class GameMap extends AcGameObject {
    constructor(playground) {
        super();
        this.playground = playground;
        this.$canvas = $(`<canvas></canvas>`);
        this.ctx = this.$canvas[0].getContext('2d');
        this.ctx.canvas.width = this.playground.width;
        this.ctx.canvas.height = this.playground.height;
        this.playground.$playground.append(this.$canvas);
    }

    start() {
    }
    
    // 修改了
    resize() {
        this.ctx.canvas.width = this.playground.width;
        this.ctx.canvas.height = this.playground.height;
    }

    update() {
        this.render();
    }

    render() {
        this.ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
        this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    }
}
```

修改之后可以看到当我们的窗口调整的时候地图是可以调整的，但是现在有两个问题，一个是没有居中，第二点就是每次调整的时候地图会先变白再渐变成黑色。地图没有居中可以使用css解决，修改game.css文件。

```css
.ac_game_playground {
    width: 100%;
    height: 100%;
    user-select: none;
    background-color: grey;
}

.ac_game_playgound canvas {
    position: relative;  
	top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
```

我们每次刷新的时候是涂一层半透明的蒙版上去，是涂上若干层之后慢慢变黑的，不是一个瞬间的过程，为了避免这个渐变的过程，我们在每次resize()之后，直接涂一层不透明的蒙版，就是直接全部涂黑，这样就不会有渐变的效果了

```javascript
class GameMap extends AcGameObject {
    constructor(playground) {
        super();
        this.playground = playground;
        this.$canvas = $(`<canvas></canvas>`);
        this.ctx = this.$canvas[0].getContext('2d');
        this.ctx.canvas.width = this.playground.width;
        this.ctx.canvas.height = this.playground.height;
        this.playground.$playground.append(this.$canvas);
    }

    start() {
    }
    
    resize() {
        this.ctx.canvas.width = this.playground.width;
        this.ctx.canvas.height = this.playground.height;
        this.ctx.fillStyle = "rgba(0, 0, 0, 1)";
        this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    }

    ……
}
```

这样就能够实现动态改变游戏界面了。但是当我们去改变窗口大小时，地图中的元素并没有等比例变化，理想的效果是游戏界面变化了地图中的元素也应该相应变化。将地图中的所有元素变为相对大小

地图中有player、skill和particle三种元素，所以我们只需要将这三种元素中的所有度量单位变为相对值，从playground的初始化的js文件开始修改

```javascript
class AcGamePlayground {
    constructor(root) {
        this.root = root;
        this.$playground = $(`
        <div class="ac_game_playground"></div>
        `);
        
        this.root.$ac_game.append(this.$playground);

        this.hide();

        this.start();
    }

    get_random_color() {
        let colors = ["blue", "red", "pink", "skyblue", "green"];
        return colors[Math.floor(Math.random() * 5)];
    }

    start() {
        let outer = this;
        
    	$(window).resize(function() {
        	outer.resize();		// 改变窗口大小就resize一下    
        });
    }
    
    resize() {
        console.log("resize");
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        let unit = Math.min(this.width / 16, this.height / 9);
        this.width = unit * 16;
        this.height = unit * 9;
        this.scale = this.height;
        
        if (this.game_map) this.game_map.resize();
    }

    show() {
        this.$playground.show();

        this.resize();
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        this.game_map = new GameMap(this);
        this.players = [];
        
        // 修改了
        this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, "white", 0.15, true));

        for (let i = 0; i < 5; i ++) {
            this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, false));
        }
    }

    hide() {
        this.$playground.hide();
    }
}
```

再进入player的js文件中，将所有的绝对变量变为相对变量

```javascript
class Player extends AcGameObject {
    constructor(playground, x, y, radius, color, speed, is_me) {
        super();
        this.playground = playground;
        this.ctx = this.playground.game_map.ctx;
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.damage_x = 0;
        this.damage_y = 0;
        this.damage_speed = 0;
        this.move_length = 0;
        this.radius = radius;
        this.color = color;
        this.speed = speed;
        this.is_me = is_me;
        this.eps = 0.01;
        this.friction = 0.9;
        this.spent_time = 0;

        this.cur_skill = null;
        
        if (this.is_me) {
            this.img = new Image();
            this.img.src = this.playground.root.settings.photo;
        }
    }

    start() {
        if (this.is_me) {
            this.add_listening_events();
        } else {
            // 修改了
            let tx = Math.random() * this.playground.width / this.playground.scale;
            let ty = Math.random() * this.playground.height / this.playground.scale;
            this.move_to(tx, ty);
        }
    }

    add_listening_events() {
        let outer = this;
        this.playground.game_map.$canvas.on("contextmenu", function(){
            return false;
        });
        this.playground.game_map.$canvas.mousedown(function(e){
            const rect = outer.ctx.canvas.getBoundingClientRect();
            if (e.which === 3) {
                // 修改了
                outer.move_to((e.clientX - rect.left) / outer.playground.scale, (e.clientY - rect.top) / outer.playground.scale);
            } else if (e.which === 1) {
                if (outer.cur_skill === "fireball") {
                    // 修改了
                    outer.shoot_fireball((e.clientX - rect.left) / outer.playground.scale, (e.clientY - rect.top) / outer.playground.scale;
                }

                outer.cur_skill = null;
            }
        });
        
        $(window).keydown(function(e) {
            if (e.which === 81) {
                outer.cur_skill = "fireball";
                return false;
            }
        });
    }

    shoot_fireball(tx, ty) {
        let x = this.x, y = this.y;
        // 修改了
        let radius = 0.01;
        let angle = Math.atan2(ty - this.y, tx - this.x);
        let vx = Math.cos(angle), vy = Math.sin(angle);
        let color = "orange";
        // 修改了
        let speed = 0.5;
        let move_length = 1;
        let damage = 0.01;
        new FireBall(this.playground, this, x, y, radius, vx, vy, color, speed, move_length, damage);
    }

    get_dist(x1, y1, x2, y2) {
        let dx = x1 - x2;
        let dy = y1 - y2;
        return Math.sqrt(dx * dx + dy * dy);
    }

    move_to(tx, ty) {
        this.move_length = this.get_dist(this.x, this.y, tx, ty);
        let angle = Math.atan2(ty - this.y, tx - this.x);
        this.vx = Math.cos(angle);
        this.vy = Math.sin(angle);
    }

    is_attacked(angle, damage) {
        for (let i = 0; i < 10 + Math.random() * 5; i ++) {
            let x = this.x, y = this.y;
            let radius = this.radius * Math.random() * 0.1;
            let angle = Math.PI * 2 * Math.random();
            let vx = Math.cos(angle), vy = Math.sin(angle);
            let speed = this.speed * 10;
            let move_length = this.radius * Math.random() * 5;
            new Particle(this.playground, x, y, radius, vx, vy, this.color, speed, move_length);
        }

        this.radius -= damage;
        if (this.radius < this.eps) {
            this.destroy();
            return false;
        }
        this.damage_x = Math.cos(angle);
        this.damage_y = Math.sin(angle);
        this.damage_speed = damage * 100;
        this.speed *= 0.8;
    }

    // 修改了
    update() {
        this.update_move();
        this.render();
    }
    
    // 修改了
    update_move() {	// 更新玩家移动
        this.spent_time += this.timedelta / 1000;
        if (!this.is_me && this.spent_time > 4 && Math.random() < 1 / 300.0) {
            let player = this.playground.players[Math.floor(Math.random() * this.playground.players.length)];
            let tx = player.x + player.speed * this.vx * this.timedelta / 1000 * 0.5;
            let ty = player.y + player.speed * this.vy * this.timedelta / 1000 * 0.5;
            this.shoot_fireball(player.x, player.y);
        }

        if (this.damage_speed > this.eps) {
            this.vx = this.vy = 0;
            this.move_length = 0;
            this.x += this.damage_x * this.damage_speed * this.timedelta / 1000;
            this.y += this.damage_y * this.damage_speed * this.timedelta / 1000;
            this.damage_speed *= this.friction;
        } else {
            if (this.move_length < this.eps) {
                this.move_length = 0;
                this.vx = this.vy = 0;
                if (!this.is_me) {
                    // 修改了
                    let tx = Math.random() * this.playground.width / this.playground.scale;
                    let ty = Math.random() * this.playground.height / this.playground.scale;
                    this.move_to(tx, ty);
                }
            } else {
                let moved = Math.min(this.move_length, this.speed * this.timedelta / 1000);
                this.x += this.vx * moved;
                this.y += this.vy * moved;
                this.move_length -= moved;
            }
        }
    }

    // 涂颜色的时候不能涂相对值，而要涂绝对值，所以需要把相对值绝对化
    render() {
        // 修改了
        let scale = this.playground.scale;
        
        if (this.is_me) {
            this.ctx.save();
            this.ctx.beginPath();
            // 修改了
            this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, Math.PI * 2, false);
            this.ctx.stroke();
            this.ctx.clip();
            // 修改了
            this.ctx.drawImage(this.img, (this.x - this.radius) * scale, (this.y - this.radius) * scale, this.radius * 2 * scale, this.radius * 2 * scale); 
            this.ctx.restore();
        } else {
            this.ctx.beginPath();
            // 修改了
            this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, Math.PI * 2, false);
            this.ctx.fillStyle = this.color;
            this.ctx.fill();
        }
    }

    on_destroy() {
        for (let i = 0; i < this.playground.players.length; i ++) {
            if (this.playground.players[i] === this) {
                this.playground.players.splice(i, 1);
            }
        }
    }
}
```

这样我们的玩家就修正了，之后再修改火球

```javascript
class FireBall extends AcGameObject {
    constructor(playground, player, x, y, radius, vx, vy, color, speed, move_length, damage) {
        super();
        this.playground = playground;
        this.player = player;
        this.ctx = this.playground.game_map.ctx;
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.speed = speed;
        this.move_length = move_length;
        this.damage = damage;
        
        // 修改了
        this.eps = 0.01;
    }

   ……

    render() {
        let scale = this.playground.scale;
        
        this.ctx.beginPath();
        this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, Math.PI * 2, false);
        this.ctx.fillStyle = this.color;
        this.ctx.fill();
    }
}
```

之后再修改打到玩家的特效

```javascript
class Particle extends AcGameObject {
    constructor(playground, x, y, radius, vx, vy, color, speed, move_length) {
        super();
        this.playground = playground;
        this.ctx = this.playground.game_map.ctx;
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.speed = speed;
        this.move_length = move_length;
        this.friction = 0.9;
        
        // 修改了
        this.eps = 0.01;
    }

    strart() {

    }

    update() {
        if (this.move_length < this.eps || this.speed < this.eps) {
            this.destroy();
            return false;
        }

        let moved = Math.min(this.move_length, this.speed * this.timedelta / 1000);
        this.x += this.vx * moved;
        this.y += this.vy * moved;
        this.speed *= this.friction;
        this.move_length -= moved;
        this.render();
    }

    render() {
        let scale = this.playground.scale;
        
        this.ctx.beginPath();
        this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, Math.PI * 2, false);
        this.ctx.fillStyle = this.color;
        this.ctx.fill();
    }
}
```



### 2、增加“联机对战”模式

修改menu的js文件

```javascript
class AcGameMenu {
    constructor(root) {
        this.root = root;
        this.$menu = $(`
html代码……
`);
        this.$menu.hide();
        this.root.$ac_game.append(this.$menu);
        this.$single_mode = this.$menu.find('.ac_game_menu_field_item_single_mode');
        this.$multi_mode = this.$menu.find('.ac_game_menu_field_item_multi_mode');
        this.$settings = this.$menu.find('.ac_game_menu_field_item_settings');

        this.start();
    }

    start() {
        this.add_listening_events();
    }

    add_listening_events() {
        let outer = this;
        this.$single_mode.click(function(){
            outer.hide();
            // 修改了
            outer.root.playground.show("single mode");
        });
        this.$multi_mode.click(function(){
            // 修改了
			outer.hide();
            outer.root.playground.show("multi mode");
        });
        this.$settings.click(function(){
            outer.root.settings.logout_on_remote();
        });
    }

    show() {
        this.$menu.show();
    }

    hide() {
        this.$menu.hide();
    }
}
```

打开playground的js文件

```javascript
class AcGamePlayground {
    constructor(root) {
        this.root = root;
        this.$playground = $(`
        <div class="ac_game_playground"></div>
        `);
        
        this.root.$ac_game.append(this.$playground);

        this.hide();

        this.start();
    }

    get_random_color() {
        let colors = ["blue", "red", "pink", "skyblue", "green"];
        return colors[Math.floor(Math.random() * 5)];
    }

    start() {
        let outer = this;
        
    	$(window).resize(function() {
        	outer.resize();		// 改变窗口大小就resize一下    
        });
    }
    
    resize() {
        console.log("resize");
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        let unit = Math.min(this.width / 16, this.height / 9);
        this.width = unit * 16;
        this.height = unit * 9;
        this.scale = this.height;
        
        if (this.game_map) this.game_map.resize();
    }

    show(mode) {
        this.$playground.show();

        this.resize();
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        this.game_map = new GameMap(this);
        this.players = [];
        this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, "white", 0.15, "me"));
		// 修改了
        if (mode === "single mode") {
            for (let i = 0; i < 5; i ++) {
                this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, "robot"));
            }
        } else if (mode === "multi mode") {
            
        }
    }

    hide() {
        this.$playground.hide();
    }
}
```

因为这里有自己、机器人、对手三种角色了，使用is_me的true和false已经不够用了，所以我们用一个新的变量character的me、robot、enemy来定义三种角色。所以所有用到了is_me的地方都需要改一遍，首先是Player第二行的构造函数中使用了is_me改为character，第24行的判断条件改为this.character !== "robot"，机器人不需要渲染头像。敌人也有照片，从settings中无法获取，所以构造players的时候需要把照片加进去

```javascript
class Player extends AcGameObject {
    // 修改了
    constructor(playground, x, y, radius, color, speed, character, username, photo) {
        super();
        this.playground = playground;
        this.ctx = this.playground.game_map.ctx;
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.damage_x = 0;
        this.damage_y = 0;
        this.damage_speed = 0;
        this.move_length = 0;
        this.radius = radius;
        this.color = color;
        this.speed = speed;
        // 修改了
        this.character = character;
        this.username = username;
        this.photo = photo;
        this.eps = 0.01;
        this.friction = 0.9;
        this.spent_time = 0;

        this.cur_skill = null;
        
        // 修改了
        if (this.charater !== "robot") {
            this.img = new Image();
            this.img.src = this.photo;
        }
    }

    start() {
        // 修改了
        if (this.character === "me") {
            this.add_listening_events();
        } else if (this.character === "robot") {
            let tx = Math.random() * this.playground.width / this.playground.scale;
            let ty = Math.random() * this.playground.height / this.playground.scale;
            this.move_to(tx, ty);
        }
    }

    add_listening_events() {
        let outer = this;
        this.playground.game_map.$canvas.on("contextmenu", function(){
            return false;
        });
        this.playground.game_map.$canvas.mousedown(function(e){
            const rect = outer.ctx.canvas.getBoundingClientRect();
            if (e.which === 3) {
                outer.move_to((e.clientX - rect.left) / outer.playground.scale, (e.clientY - rect.top) / outer.playground.scale);
            } else if (e.which === 1) {
                if (outer.cur_skill === "fireball") {
                    outer.shoot_fireball((e.clientX - rect.left) / outer.playground.scale, (e.clientY - rect.top) / outer.playground.scale;
                }

                outer.cur_skill = null;
            }
        });
        
        $(window).keydown(function(e) {
            if (e.which === 81) {
                outer.cur_skill = "fireball";
                return false;
            }
        });
    }

    shoot_fireball(tx, ty) {
        let x = this.x, y = this.y;
        let radius = 0.01;
        let angle = Math.atan2(ty - this.y, tx - this.x);
        let vx = Math.cos(angle), vy = Math.sin(angle);
        let color = "orange";
        let speed = 0.5;
        let move_length = 1;
        let damage = 0.01;
        new FireBall(this.playground, this, x, y, radius, vx, vy, color, speed, move_length, damage);
    }

    get_dist(x1, y1, x2, y2) {
        let dx = x1 - x2;
        let dy = y1 - y2;
        return Math.sqrt(dx * dx + dy * dy);
    }

    move_to(tx, ty) {
        this.move_length = this.get_dist(this.x, this.y, tx, ty);
        let angle = Math.atan2(ty - this.y, tx - this.x);
        this.vx = Math.cos(angle);
        this.vy = Math.sin(angle);
    }

    is_attacked(angle, damage) {
        for (let i = 0; i < 10 + Math.random() * 5; i ++) {
            let x = this.x, y = this.y;
            let radius = this.radius * Math.random() * 0.1;
            let angle = Math.PI * 2 * Math.random();
            let vx = Math.cos(angle), vy = Math.sin(angle);
            let speed = this.speed * 10;
            let move_length = this.radius * Math.random() * 5;
            new Particle(this.playground, x, y, radius, vx, vy, this.color, speed, move_length);
        }

        this.radius -= damage;
        if (this.radius < this.eps) {
            this.destroy();
            return false;
        }
        this.damage_x = Math.cos(angle);
        this.damage_y = Math.sin(angle);
        this.damage_speed = damage * 100;
        this.speed *= 0.8;
    }

    update() {
        this.update_move();
        this.render();
    }
    
    update_move() {	// 更新玩家移动
        this.spent_time += this.timedelta / 1000;
        // 修改了
        if (this.charater === "robot" && this.spent_time > 4 && Math.random() < 1 / 300.0) {
            let player = this.playground.players[Math.floor(Math.random() * this.playground.players.length)];
            let tx = player.x + player.speed * this.vx * this.timedelta / 1000 * 0.5;
            let ty = player.y + player.speed * this.vy * this.timedelta / 1000 * 0.5;
            this.shoot_fireball(player.x, player.y);
        }

        if (this.damage_speed > this.eps) {
            this.vx = this.vy = 0;
            this.move_length = 0;
            this.x += this.damage_x * this.damage_speed * this.timedelta / 1000;
            this.y += this.damage_y * this.damage_speed * this.timedelta / 1000;
            this.damage_speed *= this.friction;
        } else {
            if (this.move_length < this.eps) {
                this.move_length = 0;
                this.vx = this.vy = 0;
                // 修改了
                if (this.character === "robot") {
                    let tx = Math.random() * this.playground.width / this.playground.scale;
                    let ty = Math.random() * this.playground.height / this.playground.scale;
                    this.move_to(tx, ty);
                }
            } else {
                let moved = Math.min(this.move_length, this.speed * this.timedelta / 1000);
                this.x += this.vx * moved;
                this.y += this.vy * moved;
                this.move_length -= moved;
            }
        }
    }

    // 涂颜色的时候不能涂相对值，而要涂绝对值，所以需要把相对值绝对化
    render() {
        let scale = this.playground.scale;
        
        // 修改了
        if (this.character !== "robot") {
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, Math.PI * 2, false);
            this.ctx.stroke();
            this.ctx.clip();
            this.ctx.drawImage(this.img, (this.x - this.radius) * scale, (this.y - this.radius) * scale, this.radius * 2 * scale, this.radius * 2 * scale); 
            this.ctx.restore();
        } else {
            this.ctx.beginPath();
            this.ctx.arc(this.x / scale, this.y * scale, this.radius * scale, 0, Math.PI * 2, false);
            this.ctx.fillStyle = this.color;
            this.ctx.fill();
        }
    }

    on_destroy() {
        for (let i = 0; i < this.playground.players.length; i ++) {
            if (this.playground.players[i] === this) {
                this.playground.players.splice(i, 1);
            }
        }
    }
}
```



```javascript
class AcGamePlayground {
    constructor(root) {
        this.root = root;
        this.$playground = $(`
        <div class="ac_game_playground"></div>
        `);
        
        this.root.$ac_game.append(this.$playground);

        this.hide();

        this.start();
    }

    get_random_color() {
        let colors = ["blue", "red", "pink", "skyblue", "green"];
        return colors[Math.floor(Math.random() * 5)];
    }

    start() {
        let outer = this;
        
    	$(window).resize(function() {
        	outer.resize();		// 改变窗口大小就resize一下    
        });
    }
    
    resize() {
        console.log("resize");
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        let unit = Math.min(this.width / 16, this.height / 9);
        this.width = unit * 16;
        this.height = unit * 9;
        this.scale = this.height;
        
        if (this.game_map) this.game_map.resize();
    }

    show() {
        this.$playground.show();

        this.resize();
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        this.game_map = new GameMap(this);
        this.players = [];
        
        // 修改了
        this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, "white", 0.15, "me", this.root.settings.username, this.root,settings.photo));

        for (let i = 0; i < 5; i ++) {
            this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, "robot"));
        }
    }

    hide() {
        this.$playground.hide();
    }
}
```

打包调试多人模式，发现初始的人不在画面的中间，原因是因为要先生成了gamemap地图之后再进行resizse()

```javascript
show() {
    this.$playground.show();

    this.width = this.$playground.width();
    this.height = this.$playground.height();
    this.game_map = new GameMap(this);

    // 修改了resize的位置
    this.resize();

    this.players = [];

    this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, "white", 0.15, "me", this.root.settings.username, this.root,settings.photo));

    for (let i = 0; i < 5; i ++) {
        this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, "robot"));
    }
}
```

### 3、 配置channels_redis

需要实现四个同步函数create_player、move_to、shoot_fireball、attack。

要实现同步函数，服务器和客户端需要实现双向通信，此时http协议就不适用了，http只支持单向通信，我们这里使用websocket协议，配置django_channels就是django中实现wss的一种方式，wss可以看作是websocket的加密了的协议

[3. 配置channels_redis - AcWing](https://www.acwing.com/blog/content/12692/)

第五步代码讲解

```python
from channels.generic.websocket import AsyncWebsocketConsumer
import json

class MultiPlayer(AsyncWebsocketConsumer):
    async def connect(self):
        # 当前端执行this.ws = new Websocket("wss://域名地址/wss/multiplayers/");时，它就会调用accept()函数，如果同意创建连接执行一下await self.accept()就可以了，就会成功创建连接之后再处理accept
        await self.accept()
        print('accept')

        self.room_name = "room"
        # ground_add将用户加入服务器的channel组中，用来群发消息
        await self.channel_layer.group_add(self.room_name, self.channel_name)

        # 断开连接的函数disconnect，当前端刷新或者close的时候就会调用这个函数，不能用这个函数来判断用户在不在线，因为当用户因为特殊情况下线不一定会执行这个函数
    async def disconnect(self, close_code):
        print('disconnect')
        await self.channel_layer.group_discard(self.room_name, self.channel_name);

	# receive函数用来接收前端向后端发送的请求的
    async def receive(self, text_data):
        data = json.loads(text_data)
        print(data)
```



第五步创建game/consumers文件夹时，还需要在下面创建multiplayer文件夹来保存多人对战的代码，因为实现聊天室的时候也要使用到wss协议，到时候还需要创建一个聊天室的文件夹，每个文件夹下都需要创建```__init__.py```文件，再multiplayer下创建index.py文件

之后再开始前端代码，进入js的playground文件夹下创建socket文件夹，socket文件夹主要保存联机对战和聊天室的代码，进入sockt文件夹创建multiplayer文件夹，用来保存联机堆栈的代码，创建zbase.js文件

```javascript
class MultiPlayerSocket {
    constructor(playground) {
        this.playground = playground;
        
        // 路由中最后有/这里也必须要有，保持一致
        this.ws = new WebSocket("wss://域名地址/wss/multiplayer/");
        
        this.start();
    }
    
    start() {
        
    }
}
```

之后再修改routing.py路由文件

```javascript
from django.urls import path
from game.consumers.multiplayers.index import MultiPlayer

websocket_urlpatterns = [
	path("wss/multiplayer/", MultiPlayer.as_asgi(), name="wss_multiplayer"),
]
```

前端改完之后，记得将函数添加到playground中

```javascript
class AcGamePlayground {
    constructor(root) {
        this.root = root;
        this.$playground = $(`
        <div class="ac_game_playground"></div>
        `);
        
        this.root.$ac_game.append(this.$playground);

        this.hide();

        this.start();
    }

    get_random_color() {
        let colors = ["blue", "red", "pink", "skyblue", "green"];
        return colors[Math.floor(Math.random() * 5)];
    }

    start() {
        let outer = this;
        
    	$(window).resize(function() {
        	outer.resize();		// 改变窗口大小就resize一下    
        });
    }
    
    resize() {
        console.log("resize");
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        let unit = Math.min(this.width / 16, this.height / 9);
        this.width = unit * 16;
        this.height = unit * 9;
        this.scale = this.height;
        
        if (this.game_map) this.game_map.resize();
    }

    show(mode) {
        this.$playground.show();
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        this.game_map = new GameMap(this);
        
        this.resize();
        
        this.players = [];
        this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, "white", 0.15, "me"));
        if (mode === "single mode") {
            for (let i = 0; i < 5; i ++) {
                this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, "robot"));
            }
        } else if (mode === "multi mode") {
            // 修改了
            this.mps =new MultiPlayerSocket(this);
        }
    }

    hide() {
        this.$playground.hide();
    }
}
```

打包重启一下服务进行调试，wss服务器页面有用户连接信息说明部署成功了。之后再尝试向后端发送一个创建玩家消息，

```javascript
class MultiPlayerSocket {
    constructor(playground) {
        this.playground = playground;
        
        // 路由中最后有/这里也必须要有，保持一致
        this.ws = new Websocket("wss://域名地址/wss/multiplayers/");
        
        this.start();
    }
    
    start() {
        
    }
    
    send_create_player() {
        this.ws.send(JSON.stringify({
            'message': "hello acapp server",
        }));
    }
    
    receive_create_player() {
        
    }
}
```

在playground中调用

```javascript
class AcGamePlayground {
    constructor(root) {
       ……
    }

    ……

    show(mode) {
        this.$playground.show();
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        this.game_map = new GameMap(this);
        
        this.resize();
        
        this.players = [];
        this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, "white", 0.15, "me"));
        if (mode === "single mode") {
            for (let i = 0; i < 5; i ++) {
                this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, "robot"));
            }
        } else if (mode === "multi mode") {
            this.mps =new MultiPlayerSocket(this);
            
            // 修改了
            this.mps.ws.onopen = function() {
                outer.mps.send_create_player();
            };
        }
    }

   ……
}
```

后端接收到了hello acapp server，说明连接已经创建好了

### 4.、编写同步函数

联机的时候游戏中的每个元素在每个client上都有一个备份，我们需要保持所有元素在每个client上都是一样的，我们就给所有的东西都给一个唯一的编号，在同步时就知道同步谁，我们把同步编号的功能放在ac_game_objects的js文件中

```javascript
let AC_GAME_OBJECTS = [];

class AcGameObject {
    constructor() {
        AC_GAME_OBJECTS.push(this);

        this.has_called_start = false;
        this.timedelta = 0;
        
      	// 修改了
        this.uuid = this.create_uuid();
        console.log(this.uuid);
    }
    
    // 修改了
    // 创建唯一编号，随机一个多位数就好，可以近似的认为不会出现重复
    create_uuid () {
        let res = "";
        for (let i = 0; i < 0; i ++) {
            let x = parseInt(Math.floor(Math.random() * 10)); // 返回[0, 10)之间的数
            res += x;
        }
        
        return res;
    }

…………
```

这样每个client都会给游戏中的元素创建一个uuid，这样一个元素就有多个uuid了，这样还是达不到我们要的效果，我们规定，每个元素的uuid等于创建它的client产生的uuid，这样就可以通过uuid去分辨元素了

还有一个问题就是，如果我们创建了一个3号玩家，client会向服务器发送一个3号玩家的创建信息，服务器会给所有的client进行广播，服务器会再给3号玩家的client再广播一遍，这个client在接收到服务器发送的这条消息时就应该pass掉，因此在接收消息时我们就需要判断一下信息时谁发的，这样client在向服务器发送信息时就需要带上自己的player的uuid，

```javascript
class AcGamePlayground {
    constructor(root) {
       ……
    }

    ……

    show(mode) {
        this.$playground.show();
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        this.game_map = new GameMap(this);
        
        this.resize();
        
        this.players = [];
        this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, "white", 0.15, "me"));
        if (mode === "single mode") {
            for (let i = 0; i < 5; i ++) {
                this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, "robot"));
            }
        } else if (mode === "multi mode") {
            this.mps =new MultiPlayerSocket(this);
            this.mps.uuid = this.player[0].uuid;
            
            // 修改了
            this.mps.ws.onopen = function() {
                outer.mps.send_create_player();
            };
        }
    }

   ……
}
```

```javascript
class MultiPlayerSocket {
    constructor(playground) {
        this.playground = playground;
        
        // 路由中最后有/这里也必须要有，保持一致
        this.ws = new Websocket("wss://域名地址/wss/multiplayers/");
        
        this.start();
    }
    
    start() {
        
    }
    
    send_create_player() {
        this.ws.send(JSON.stringify({
            'event': "create_player",
            'uuid': outer.uuid,
        }));
    }
    
    receive_create_player() {
        
    }
}
```

打包调试一下，看能不能得到event和uuid。接下来实现create_player这个事件，当来一个新的玩家的时候需要在每一个窗口里面创建一个玩家，同时将已有的玩家渲染到窗口中，服务器端需要存下每局对战的信息，存到时候可以存到redis中，暂时以3个人为一个房间进行存储，在settings.py中修改房间人数上限，在最后加一句```ROOM_CAPACITY = 3```

```python
from channels.generic.websocket import AsyncWebsocketConsumer
import json
from django.conf import settings
from django.core.cache import cache

class MultiPlayer(AsyncWebsocketConsumer):
    async def connect(self):
        self.room_name = None
        
        for i in rage(1000): # 服务器房间暂定为1000个
            name = "room-%d" % (i)
            if not cache.has_key(name) or len(cache.get(name)) < settings.ROOM_CAPACITY):
                self.room_name = name
                break;
        if not self.room_name:
            return
        
        await self.accept()
        
        if not cache.has_keys(self.room_name):
            cache.set(self.room_name, [], 3600) # 有效期一小时
        
        for player in cache.get(self.room_name):
            await self.send(text_date = json.dumps({
                'event': "create_player",
                'uuid': player['uuid'],
                'username': player['username'],
                'photo': player['photo'],
            }))

        self.room_name = "room"
        await self.channel_layer.group_add(self.room_name, self.channel_name)

    async def disconnect(self, close_code):
        print('disconnect')
        await self.channel_layer.group_discard(self.room_name, self.channel_name);


    async def receive(self, text_data):
        data = json.loads(text_data)
        print(data)
```

```javascript
class AcGamePlayground {
    constructor(root) {
       ……
    }

    ……

    show(mode) {
        this.$playground.show();
        
        this.width = this.$playground.width();
        this.height = this.$playground.height();
        this.game_map = new GameMap(this);
        
        this.resize();
        
        this.players = [];
        this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, "white", 0.15, "me"));
        if (mode === "single mode") {
            for (let i = 0; i < 5; i ++) {
                this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, "robot"));
            }
        } else if (mode === "multi mode") {
            this.mps =new MultiPlayerSocket(this);
            this.mps.uuid = this.player[0].uuid;
            
            // 修改了
            this.mps.ws.onopen = function() {
                outer.mps.send_create_player(outer.root.settings.username, outer.root.settings.photo);
            };
        }
    }

   ……
}
```

实现send_create_palyer函数

```java
class MultiPlayerSocket {
    constructor(playground) {
        this.playground = playground;
        
        // 路由中最后有/这里也必须要有，保持一致
        this.ws = new Websocket("wss://域名地址/wss/multiplayers/");
        
        this.start();
    }
    
    start() {
        
    }
    
    send_create_player(username, photo) {
        let outer = this;
        
        this.ws.send(JSON.stringfy({
            'message': "hello acapp server",
            'uuid': outer.uuid,
            'username': username,
            'photo': photo,
        }));
    }
    
    receive_create_player() {
        
    }
}
```



```python
from channels.generic.websocket import AsyncWebsocketConsumer
import json
from django.conf import settings
from django.core.cache import cache

class MultiPlayer(AsyncWebsocketConsumer):
    async def connect(self):
        self.room_name = None
        
        for i in rage(1000): # 服务器房间暂定为1000个
            name = "room-%d" % (i)
            if not cache.has_key(name) or len(cache.get(name)) < settings.ROOM_CAPACITY):
                self.room_name = name
                break;
        if not self.room_name:
            return
        
        await self.accept()
        
        if not cache.has_keys(self.room_name):
            cache.set(self.room_name, [], 3600) # 有效期一小时
        
        for player in cache.get(self.room_name):
            await self.send(text_date = json.dumps({
                'event': "create_player",
                'uuid': player['uuid'],
                'username': player['username'],
                'photo': player['photo'],
            }))

        self.room_name = "room"
        await self.channel_layer.group_add(self.room_name, self.channel_name)

    async def disconnect(self, close_code):
        print('disconnect')
        await self.channel_layer.group_discard(self.room_name, self.channel_name);
        
    # 修改了
    async def create_player(self, data):
        players = cache.get(self.room_name)
        players.append({
            'uuid': data['uuid'],
            'username': data['username'],
            'photo': data['photo'],
        })
        cache.set(self.room, players, 3600)
        await self.channel_layer.group_send(
        	self.room_name, 
            {
                # type是接收信息的函数的名字
                'type': "grounp_create_players",
                'event': "create_palyer",
                'uuid': data['uuid'],
                'username': data['username'],
                'photo': data['photo'],
            }
        )
   
	async def grounp_create_player(self, data):
        await self.send(text_data=json.dumps(data))
        
    async def receive(self, text_data):
        data = json.loads(text_data)
       	# 修改了
        event = data['event']
        if event == "create_player":
            await self.create_player(data)
```



```javascript
class MultiPlayerSocket {
    constructor(playground) {
        this.playground = playground;
        
        // 路由中最后有/这里也必须要有，保持一致
        this.ws = new Websocket("wss://域名地址/wss/multiplayers/");
        
        this.start();
    }
    
    start() {
        
    }
    
    receive() {
        let outer = this;
        
        this.ws.onmessage = function(e) {
            let data = JSON.parse(e.data);
            let uudi = data.uuid;
            if (uuid === outer.uuid) return false;
            
            let event = data.event;
            if (event === "create_player") {
                outer.receive_create_player(uuid, data.usernem, data.photo);
            }
        };
    }
    
    send_create_player() {
        let outer = this;
        
        this.ws.send(JSON.stringfy({
            'message': "hello acapp server",
            'uuid': outer.uuid,
            'username': username,
            'photo': photo,
        }));
    }
    
    receive_create_player(uuid , username, photo) {
        let player = new Player(
            this.playerground, 
            this.playground.width / 2 / this.playground.scale,
            0.5,
            0.05,
            "white",
            0.15,
            'enemy',
            username,
            photo,
        );
        
        player.uuid = uuid;
        this.playeground.players.push(player);
    }
}
```

然后进行调试，在player类的的构造函数中输出创建的用户的信息

清空redis缓存的方法，进入django的shell

```python
from django.core.cache import cache

def clear():
    for key in cache.keys('*'):
        cache.delete(key)
      	
clear()
```



### 查看当前的房间及房间信息

进入`django shell`：`python manage.py shell`

导入`cache`：`from django.core.cache import cache`

查询当前的房间：`cache.keys('*')`

获取当前的房间信息：`cache.get('得到的key')`

注意事项：以上命令基于`django_redis`，所以需要安装`django_redis`，然后在`settings.py`中将`CACHES`设置为`django_redis`

