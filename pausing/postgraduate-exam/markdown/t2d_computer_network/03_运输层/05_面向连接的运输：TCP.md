## 3.5 面向连接的运输：TCP

### 3.5.1 TCP连接

- TCP是**面向连接**的，是因为它在传输数据之间需要经过“三次握手”。这种TCP连接不是一条像在电路交换网络中的端到端的TDM或FDM电路，相反，该“连接”是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中；
- TCP连接提供的是**全双工服务**，**点对点**的连接；

**TCP连接的建立过程**：

- 客户应用进程通知客户运输层，它想与某一个服务器上的某个进程建立连接，即`clientSocket.connect((serverName, serverPort))`；

- 客户运输层接收到应用进程的通知后，开始与`serverName`的`serverPort`建立连接，即“三次握手”过程；

- 连接建立后，开始传输数据，当客户应用程序通过套接字向运输层发送数据之后，TCP会将这些数据引导到该连接的**发送缓存**中(发送缓存是发起三次握手器件设置的缓存之一)，接下来TCP会不时的从发送缓存中取出数据，TCP为每块数据配上一个TCP首部，形成多个**TCP报文段**，然后下传给网络层，网络层加其分别封装在网络层的**IP数据报**中，然后再将这些IP数据报发送到网络中；

  > TCP可从缓存中取出并放入报文段中的数据数量受限于**最大报文段长度**(Maximum Segment Sizse, MSS)。MSS通常根据本地主机发送的最大链路层帧长度(Maximum Transmission Unit, MTU)来设置，设置MSS要保证一个TCP报文段加上TCP/IP首部长度将适合单个链路层帧，TCP/IP首部一般为40字节，以太网和PPP链路层协议的MTU = 1500B，所以MSS可设置为1460B；
  >
  > MSS是指在报文段中应用层数据的最大长度，不包括TCP首部

- 当TCP在另一端接收到一个报文段后，该报文段的数据将会被放入TCP连接的**接收缓存**中

### 3.5.2 TCP报文段结构

![image-20231023135803382](C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231023135803382.png)

- **序号(ACK)和确认号(Seq)**：TCP将数据看成是一个无结构的、有序的字节流，因此一个报文段的序号是该**报文段首字节的字节流编号**；主机A填充进报文段的确认号是**主机A期望从主机B收到的下一字节的序号**；

  > TCP的初始序号不一定为0。事实上，一条TCP连接的双方均可随机地选择初始序号

- Telnet：序号和确认号学习的一个例子

  > Telnet是一个用于远程登录协议，它运行在TCP之上；大多数用户选择使用SSH协议进行远程登陆，而不是Telnet协议，因为Telnet在连接中发送的数据是没有加密的(包括口令)；

  使用Telnet协议时，用户键入的每个字符都会被发送至远程主机，之后，远程主机会将字符回送给客户，并将这些字符显示在Telnet用户的屏幕上，这种“回显”用于确保由Telnet用户发送的字符已经被远程主机收到并在远程站点上得到了处理，因此，从用户击键到字符被显示在用户屏幕上的这段事件中，每个字符在网络中传输了两次，我们接下来将讨论这个数据传输的过程；

  <img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231023145948227.png" alt="image-20231023145948227" style="zoom:67%;" />

### 3.5.3 往返时间的估计与超时

- 估计往返时间：
  - **样本RTT(SampleRTT)**为从某报文段被发出(即交给IP)到对该报文段的确认被收到之间的时间量。大多数TCP的实现仅在某个时刻做一次SampleRTT的测量，而不是为每个发送的报文段测量一个SampleRTT(TCP不为重传的报文段测量SampleRTT)
  - **典型RTT(EstimatedRTT)** = (1 - α)EstimatedRTT + αSampleRTT（α一般取0.125）
  - **RTT偏差(DevRTT)** = (1 - β)DevRTT + β |SampleRTT - EstimatedRTT|。SampleRTT的值波动较小，DevRTT的值就会很小，β的值推荐为0.25
- 设置和管理重传超时间隔：TimeoutInterval = EstimatedRTT + 4DevRTT。TimeoutInterval的初始值推荐为1秒，当出现超时后，TimeoutInterval的值将加倍，以免即将被确认的后继报文段过早出现超时，只要接收到报文段更新EstimatedRTT后，就用上述公式重新计算TimeoutInterval

### 3.5.4 可靠数据传输

```c
/* 假定发送方不受TCP流量和拥塞控制的限制，来自上层的数据长度小于MSS，且数据传送指在一个方向进行 */
NextSeqNum = InitialSeqNumber;
SendBase = InitialSeqNumber;

loop (true) {
	switch (事件)
		事件：从上面应用程序接收到数据e
			生成具有序号NextSeqNum的TCP报文
			if (定时器当前没有运行) 启动定时器
			向IP传递报文段
			NextSeqNum = NextSeqNum + length(data);
			break;
			
		事件：定时器超时
			重传具有最小序号但仍未应答的报文段
			启动定时器
			break;
		
		事件：收到ACK，具有ACK字段值y
			if (y > SendBase) {
				SendBase = y;
				if (当前有未被确认的报文段) 启动定时器
			}
			break;
}
```

- **超时间隔加倍：**每当超时事件发生时，TCP重传具有最小序号的还未被确认的报文段，每次TCP重传时都会将下一次的超时间隔设为先前的两倍，而不是用EstimatedRTT和DevRTT推算出来的值，当发送方收到上层应用的数据或收到ACK时，超时间隔由最近的EstimatedRTT和DevRTT推算得到；这种修改提供了一个形式受限的拥塞控制；

- **快速重传：**因为发送方使用流水线方式发送报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK，一般规定，如果TCP发送方接收到对相同数据的3个冗余ACK，TCP就执行快速重传；

  ```
  事件：收到ACK，具有ACK字段值y
  if (y > SendBase) {
      SendBase = y;
      if (当前有未被确认的报文段) 启动定时器
  } else {
  	对y收到的冗余ACK数加1
  	if (对y收到的冗余ACK数 == 3)
  		/* TCP快速重传 */
  		重新发送具有序号y的报文段
  }
  break;

- **使用回退N帧还是选择重传**：由发送方在接收到ACK之后的操作`if (y > SendBase) SendBase = y`可以得到TCP的确认是累积的，类似于GBN，因此推测TCP的接收方也与GBN类似，按序接收；由书中的例子，可得对于不是按序到达的报文段TCP并没有直接丢弃而是缓存了下来，这也是TCP超时后只重传一个分组的原因；

  > 例子：当发送方发送一组报文段1、2、3 . . . N，并且所有报文段都按序无差错地到达接收方时，若分组n<N的确认报文丢失，但是其余N - 1个确认报文在超时前分别到达了发送方，GBN协议不仅会重传分组n，还会重传后继的分组n + 1、n + 2、... 、N；TCP协议将至多重传一个报文，即报文段n，如果对报文段n + 1的确认报文在报文段n超时之前到达，TCP甚至不会重传报文段n

### 3.5.5 流量控制

假设需要发送大量数据的情况下，当应用程序读取数据的速度比发送方发送数据的速度慢很多的时候，接收方就会出现缓存溢出的情况，为了解决缓存溢出，TCP为它的应用程序提供了流量控制服务；

> 注意**流量控制和拥塞控制的区别**，流量控制是用来防止接收方缓存溢出的；而拥塞控制是为了防止IP网络的拥塞

TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制。即接收方告诉发送方自己还有多少可用的缓存空间，**接收方**为了知道自己还有多少空间，在应用进程中**定义了以下四个变量**：

- LastByteRead：从缓存中读出的数据流的最后一个字节的编号；
- LastByteRcvd：从网络中到达的并且已放入主机接收缓存中的数据流的最后一个字节的编号
- RcvBuffer(接收缓存) >= LastByteRcvd - LastByteRead
- rwnd(接收窗口) = RcvBuffer - [LastByteRcvd - LastByteRead]

接收方通过把当前rwnd值放入它发给主机A的报文段的接收窗口中，通知发送方在该连接的缓存中还有多少可用空间。初始时rwnd = RcvBuffer；同样，在**发送方**中**也要定义一些变量**来实现流量控制：

- LastByteSent：发送方发出的最后一个字节
- LastByteAcked：发送方中最早未被确认的字节

LastByteSent - LastByteAcked为发送方发送到连接中但未被确认的数据量，通过将未被确认的数据量控制在值rwnd内，就可以保证发送方不会时接收方的接收缓存溢出

**特殊情况：**接收方的rwnd是通过放在发送给发送方的报文段中的，如果接收方在将rwnd = 0通告给主机之后，而且接收方的发送缓存为空(接收方没有数据发送给发送方)，此时，该连接中的发送方的rwnd就会一直为0，从而阻塞发送方发送数据

为了解决这种特殊情况，TCP规范要求：当接收方的rwnd = 0时，发送方继续发送只有一个字节数据的报文段，这些报文段将会被接收方正确接收，这样，rwnd就可以通过接收方的确认报文进行更新了；

### 3.5.6 TCP连接管理

建立一条TCP连接的过程。首先，客户应用程序通知客户TCP——它想建立一个与服务器上某个进程之间的连接，客户服务器中的TCP会用以下方式与服务器中的TCP**建立一条TCP连接**：

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231023214817061.png" alt="image-20231023214817061" style="zoom:67%;" />

> 三次握手一旦完成，客户和服务器就可以相互发送包括数据的报文了，在以后的每一个报文中，SYN比特都将被置0

有建立连接的过程，自然也就有终止连接的过程，接下来介绍这一过程，注意，参与一条TCP连接的两个进程中的任何一方都可以终止该连接，当连接结束后，主机中的“资源”（即缓存和变量）将被释放；现举一个**客户主动关闭连接**的例子：

<img src="C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231023220401714.png" alt="image-20231023220401714" style="zoom:50%;" />

下图是在一个TCP连接的生命周期内，运行在每台主机中的TCP协议在**各种TCP状态之间的变迁**，在初始时都是处于CLOSED状态，客户端等待应用程序发起TCP连接；服务器等待应用程序创建监听套接字；

> 在下面的这两个图中只给出了TCP连接是如何正常地被建立和拆除的，并没有描述一些不正常的情况，比如连接的双方同时都要发起或终止一条连接或分组丢失等情况

![image-20231023220537868](C:\Users\ndream\AppData\Roaming\Typora\typora-user-images\image-20231023220537868.png)

当一台主机接收到与主机上的所有套接字都不匹配(端口号或源IP地址不匹配)的报文时会如何处理？

- 对于TCP，主机将向源发送一个特殊的重置报文段，即将TCP报文段中的RST标志位置为1，它告诉源“我没有那个报文段的套接字，请不要再发送该报文段了”；
- 对于UDP，主机将向源发送一个特殊的ICMP数据报；
